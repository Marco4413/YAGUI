--[[
Copyright (c) 2019, hds536jhmk : https://github.com/hds536jhmk/YAGUI

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
--]]
local a={ver="1.28",author="hds536jhmk",website="https://github.com/hds536jhmk/YAGUI/",documentation="https://hds536jhmk.github.io/YAGUI/",copyright="Copyright (c) 2019, hds536jhmk : https://github.com/hds536jhmk/YAGUI\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE."}local b={TIMER="timer",TOUCH="screen_touch",MOUSEUP="mouse_up",MOUSEDRAG="mouse_drag",MOUSESCROLL="mouse_scroll",CHAR="char",KEY="key",KEYUP="key_up",PASTE="paste",REDNET="rednet_message",MODEM="modem_message",TERMINATE="terminate",DELETED="DELETED",NONE="NONE",ALL="ALL",SEND="SEND",RECEIVE="RECEIVE",HOST="HOST",USER="USER",DISCONNECTED="DISCONNECTED",CONNECTION_REQUEST="CONNECTION_REQUEST",OK="OK",NO="NO",ERROR="ERROR",LOW_PRIORITY=1,HIGH_PRIORITY=2,ONSTART=1,ONSTOP=2,ONDRAW=3,ONPRESS=4,ONFAILEDPRESS=5,ONTIMEOUT=6,ONCLOCK=7,ONEVENT=8,ONFOCUS=9,ONKEY=10,ONCHAR=11,ONMOUSESCROLL=12,ONCURSORCHANGE=13,ONWRITE=14,ONCONNECT=15,ONDISCONNECT=16,ONSEND=17,ONRECEIVE=18,ONDRAG=19,ONRESIZE=20,MOUSE_LEFT=1,MOUSE_RIGHT=2,MOUSE_MIDDLE=3,SCROLL_UP=-1,SCROLL_DOWN=1,COMPUTER="computer",TURTLE="turtle",POCKET="pocket",ALIGN_LEFT=1,ALIGN_CENTER=2,ALIGN_RIGHT=3}for c,d in next,keys do if type(d)=="number"then b["KEY_"..c:upper()]=d end end;local e={__call=function(self,...)return self.new(...)end}e.__index=e;local f={}local g={}local h={}local i={}local j={}local k={}local l={}local m={}f={set_callback=function(n,o,p)if o==b.ONSTART then n.callbacks.onStart=p elseif o==b.ONSTOP then n.callbacks.onStop=p elseif o==b.ONDRAW then n.callbacks.onDraw=p elseif o==b.ONPRESS then n.callbacks.onPress=p elseif o==b.ONFAILEDPRESS then n.callbacks.onFailedPress=p elseif o==b.ONTIMEOUT then n.callbacks.onTimeout=p elseif o==b.ONCLOCK then n.callbacks.onClock=p elseif o==b.ONEVENT then n.callbacks.onEvent=p elseif o==b.ONFOCUS then n.callbacks.onFocus=p elseif o==b.ONKEY then n.callbacks.onKey=p elseif o==b.ONCHAR then n.callbacks.onChar=p elseif o==b.ONMOUSESCROLL then n.callbacks.onMouseScroll=p elseif o==b.ONCURSORCHANGE then n.callbacks.onCursorChange=p elseif o==b.ONWRITE then n.callbacks.onWrite=p elseif o==b.ONCONNECT then n.callbacks.onConnect=p elseif o==b.ONDISCONNECT then n.callbacks.onDisconnect=p elseif o==b.ONSEND then n.callbacks.onSend=p elseif o==b.ONRECEIVE then n.callbacks.onReceive=p elseif o==b.ONDRAG then n.callbacks.onDrag=p elseif o==b.ONRESIZE then n.callbacks.onResize=p end end,get_computer_type=function()local q=b.COMPUTER;if turtle then q=b.TURTLE elseif pocket then q=b.POCKET end;return q,term.isColor()end,expect=function(r,...)local s={...}local t="[/%.,]"r=r or"unknown"r=tostring(r)local u=false;local v;for w=1,#s,2 do local x=tostring(s[w])local y=true;local z;for A,B in next,g.split(x,t)do local C=s[w+1]local D=type(C)if D~=B then z=D else y=false;break end end;if y then local E=x:gsub(t,", ")v=string.format("\"%s\": Bad argument #%d (expected %s, got %s)",r,(w+1)/2,E,z)u=true;break end end;if u then error(v,3)return false end;return true end}g={magic_characters={"(",")",".","%","+","-","*","?","[","]","^","$"},join=function(F,G)G=G or""local H=""for d=1,#F do local I=F[d]H=H..tostring(I)..(d<#F and G or"")end;return H end,split=function(H,G)if not string.find(H,G)then return{H}end;local J={}local K="(.-)"..G.."()"local L;for M,N in string.gfind(H,K)do table.insert(J,M)L=N end;table.insert(J,string.sub(H,L))return J end,split_by_char=function(H,O)local P={}local Q=1;for w=1,#H do if H:sub(w,w)==O then table.insert(P,w==Q and""or H:sub(Q,w-1))Q=w+1 end end;table.insert(P,H:sub(Q,#H))return P end,compare_versions=function(R,S)local T=g.split(R,".")local U=g.split(S,".")local V=#T;local W=#U;for w=1,math.min(V,W)do if tonumber(T[w])>tonumber(U[w])then return 1 elseif tonumber(T[w])<tonumber(U[w])then return-1 end end;if V>W then return 1 elseif V<W then return-1 end;return 0 end,escape_magic_characters=function(H)for d,X in next,g.magic_characters do H=H:gsub("[%"..X.."]",'%%%'..X)end;return H end,get_extension=function(Y)local Z,_=Y:gsub(".*%.","")if _>0 then return Z end;return""end,format_number=function(a0,a1)a0=tostring(a0)a1=a1 or 0;local a2=a0:gsub("(.*)%..*","%1")if a1<=0 then return a2 end;local a3=#a2+1;local a4=a0:sub(a3+1,a3+a1)a4=a4:reverse():gsub("0*(.*)","%1"):reverse()if#a4>0 then return a2 .."."..a4 end;return a2 end,trim=function(H)return H:gsub("^%s*(.*)%s*$","%1")end}h={Vector2={new=function(a5,a6)local a7={x=a5 or 0,y=a6 or 0}setmetatable(a7,h.Vector2)return a7 end,duplicate=function(self)return h.Vector2.new(self.x,self.y)end,length_sq=function(self)return math.pow(self.x,2)+math.pow(self.y,2)end,length=function(self)return math.sqrt(self:length_sq())end,unit=function(self)return self/self:length()end,dot=function(self,a8)return self.x*a8.x+self.y*a8.y end,cross=function(self,a8)return self.x*a8.y-self.y*a8.x end,rotate=function(self,a9)local aa=math.cos(a9)local ab=math.sin(a9)return h.Vector2.new(aa*self.x-ab*self.y,ab*self.x+aa*self.y)end,string=function(self,a1)if a1 then return string.format("(%."..tostring(a1).."f; %."..tostring(a1).."f)",self.x,self.y)else return string.format("(%f; %f)",self.x,self.y)end end,__tostring=function(self)return self:string(0)end,__len=function(self)return self:length()end,__add=function(self,a8)return h.Vector2.new(self.x+a8.x,self.y+a8.y)end,__sub=function(self,a8)return h.Vector2.new(self.x-a8.x,self.y-a8.y)end,__mul=function(self,a0)if type(self)=="number"then return h.Vector2.new(a0.x*self,a0.y*self)else return h.Vector2.new(self.x*a0,self.y*a0)end end,__div=function(self,a0)return h.Vector2.new(self.x/a0,self.y/a0)end,__eq=function(self,a8)return self.x==a8.x and self.y==a8.y end,__lt=function(self,a8)return self:length_sq()<a8:length_sq()end,__le=function(self,a8)return self:length_sq()<=a8:length_sq()end},Vector3={new=function(a5,a6,ac)local ad={x=a5 or 0,y=a6 or 0,z=ac or 0}setmetatable(ad,h.Vector3)return ad end,duplicate=function(self)return h.Vector3.new(self.x,self.y,self.z)end,length_sq=function(self)return math.pow(self.x,2)+math.pow(self.y,2)+math.pow(self.z,2)end,length=function(self)return math.sqrt(self:length_sq())end,unit=function(self)return self/self:length()end,dot=function(self,a8)return self.x*a8.x+self.y*a8.y+self.z*a8.z end,cross=function(self,a8)return h.Vector3.new(self.y*a8.z-self.z*a8.y,self.z*a8.x-self.x*a8.z,self.x*a8.y-self.y*a8.x)end,rotate=function(self,ae,a9)local aa=math.cos(a9)return aa*self+math.sin(a9)*ae:cross(self)+(1-aa)*ae:dot(self)*ae end,string=function(self,a1)if a1 then return string.format("(%."..tostring(a1).."f; %."..tostring(a1).."f; %."..tostring(a1).."f)",self.x,self.y,self.z)else return string.format("(%f; %f; %f)",self.x,self.y,self.z)end end,__tostring=function(self)return self:string(0)end,__len=function(self)return self:length()end,__add=function(self,a8)return h.Vector3.new(self.x+a8.x,self.y+a8.y,self.z+a8.z)end,__sub=function(self,a8)return h.Vector3.new(self.x-a8.x,self.y-a8.y,self.z-a8.z)end,__mul=function(self,a0)if type(self)=="number"then return h.Vector3.new(a0.x*self,a0.y*self,a0.z*self)else return h.Vector3.new(self.x*a0,self.y*a0,self.z*a0)end end,__div=function(self,a0)return h.Vector3.new(self.x/a0,self.y/a0,self.z/a0)end,__eq=function(self,a8)return self.x==a8.x and self.y==a8.y and self.z==a8.z end,__lt=function(self,a8)return self:length_sq()<a8:length_sq()end,__le=function(self,a8)return self:length_sq()<=a8:length_sq()end},map=function(I,af,ag,ah,ai,aj)local ak=(I-af)/(ag-af)*(ai-ah)+ah;if aj then return h.constrain(ak,ah,ai)end;return ak end,constrain=function(I,al,am)return math.min(am,math.max(al,I))end,round=function(a0)return math.floor(a0+0.5)end,round_numbers=function(...)local an={...}local ao={}for d,a0 in next,an do table.insert(ao,h.round(a0))end;return table.unpack(ao)end,floor_numbers=function(...)local an={...}local ap={}for d,a0 in next,an do table.insert(ap,math.floor(a0))end;return table.unpack(ap)end,ceil_numbers=function(...)local an={...}local aq={}for d,a0 in next,an do table.insert(aq,math.ceil(a0))end;return table.unpack(aq)end}h.Vector2.__index=h.Vector2;h.Vector3.__index=h.Vector3;h.Vector2.ONE=h.Vector2.new(1,1)h.Vector2.UP=h.Vector2.new(0,-1)h.Vector2.DOWN=h.Vector2.new(0,1)h.Vector2.LEFT=h.Vector2.new(-1,0)h.Vector2.RIGHT=h.Vector2.new(1,0)h.Vector2.ZERO=h.Vector2.new(0,0)h.Vector3.ONE=h.Vector3.new(1,1,1)h.Vector3.UP=h.Vector3.new(0,1,0)h.Vector3.DOWN=h.Vector3.new(0,-1,0)h.Vector3.LEFT=h.Vector3.new(-1,0,0)h.Vector3.RIGHT=h.Vector3.new(1,0,0)h.Vector3.FORWARD=h.Vector3.new(0,0,1)h.Vector3.BACK=h.Vector3.new(0,0,-1)h.Vector3.ZERO=h.Vector3.new(0,0,0)i={has_value=function(F,I)for ar,as in next,F do if as==I then return true,ar end end;return false,nil end,has_key=function(F,d)if F[d]~=nil then return true,F[d]end;return false,nil end,serialise=function(F,at,au,av,aw,ax,ay,az,aA)local at=at or 0;local ay=ay or"  "local aB=0;local az=az or"\n"local aA=aA or" "if not au then ay,az,aA="","",""end;local aC="root"local aD={[F]=aC}local function aE(F,Y)local aF=ay:rep(aB+1)local aG="{"..az;local function aH(F)local aI=#F;local aJ=0;for d,I in next,F do local aK=type(d)local aL;if aK=="string"or aK=="table"then aL=string.format("%q",tostring(d))else aL=tostring(d)end;if not ax and d=="__index"then I={}end;local aM=type(I)if aK=="number"and d<=aI and d==aJ+1 then aJ=d;aG=aG..aF else aG=aG..string.format("%s[%s]%s=%s",aF,aL,aA,aA)end;if aM=="table"then if not next(I)then aG=aG.."{}"elseif at<=-1 or aB<at then if aD[I]and not av then aG=aG..string.format("%q",aD[I])else local aN=Y.."["..aL.."]"aD[I]=aN;aB=aB+1;aG=aG..aE(I,aN)aB=aB-1 end else aG=aG.."{}"end elseif aM=="string"or aM=="function"then aG=aG..string.format("%q",tostring(I))else aG=aG..string.format("%s",tostring(I))end;if next(F,d)then aG=aG..","..az else aG=aG..az end end end;local aO=getmetatable(F)if aw and aO then aH(aO)if next(F)then aG=aG:sub(1,#aG-#az)..","..aG:sub(#aG-#az+1)end end;aH(F)aG=aG..ay:rep(aB).."}"return aG end;return aE(F,aC)end,unserialise=textutils.unserialise,unserialize=textutils.unserialize,better_unpack=function(F,w,aP)w=w or 1;aP=aP or#F;if w<=aP then return F[w],i.better_unpack(F,w+1,aP)end end,get=function(F,Y,aQ)aQ=aQ or 1;if aQ<=#Y then local aR=F[Y[aQ]]return i.get(aR,Y,aQ+1)else return F end end,set=function(I,F,Y,aQ)local aS=table.remove(Y)aQ=aQ or 1;local aT=i.get(F,Y,aQ)local aU=aT[aS]aT[aS]=I;return aU end}i.serialize=i.serialise;j={colors={[1]="0",[2]="1",[4]="2",[8]="3",[16]="4",[32]="5",[64]="6",[128]="7",[256]="8",[512]="9",[1024]="a",[2048]="b",[4096]="c",[8192]="d",[16384]="e",[32768]="f"},paint={},color_to_paint=function(aV)return j.colors[aV]end,paint_to_color=function(aW)return j.paint[aW]end}for d,I in next,j.colors do j.paint[I]=d end;k={is_area_pressed=function(aX,aY,a5,a6,aZ,a_)if aX>=a5 and aX<a5+aZ then if aY>=a6 and aY<a6+a_ then return true end end;return false end,format_event_table=function(b0)local o={}o.name=b0[1]if o.name=="timer"then o.name=b.TIMER;o.id=o[2]elseif o.name=="mouse_click"then o.name=b.TOUCH;o.from="terminal"o.button=b0[2]o.x=b0[3]o.y=b0[4]elseif o.name=="monitor_touch"then o.name=b.TOUCH;o.from=b0[2]o.button=1;o.x=b0[3]o.y=b0[4]elseif o.name=="mouse_drag"then o.name=b.MOUSEDRAG;o.button=b0[2]o.x=b0[3]o.y=b0[4]elseif o.name=="mouse_up"then o.name=b.MOUSEUP;o.button=b0[2]o.x=b0[3]o.y=b0[4]elseif o.name=="mouse_scroll"then o.name=b.MOUSESCROLL;o.direction=b0[2]o.x=b0[3]o.y=b0[4]elseif o.name=="char"then o.name=b.CHAR;o.char=b0[2]elseif o.name=="key"then o.name=b.KEY;o.key=b0[2]elseif o.name=="key_up"then o.name=b.KEYUP;o.key=b0[2]elseif o.name=="paste"then o.name=b.PASTE;o.paste=b0[2]elseif o.name=="rednet_message"then o.name=b.REDNET;o.from=b0[2]o.message=b0[3]local b1=b0[4]if type(b1)=="number"then o.distance=b1 else o.protocol=tostring(b1)end elseif o.name=="modem_message"then local b2=b0[5]o.name=b.MODEM;o.side=b0[2]o.from=b0[4]o.protocol=b2.sProtocol or""o.message=b2.message elseif o.name=="terminate"then o.name=b.TERMINATE else o.parameters={}for d=2,#b0 do table.insert(o.parameters,b0[d])end end;o.raw=b0;return o end}l={_path="/.settings",set=function(b3,I)settings.set(b3,I)settings.save(l._path)end,unset=function(b3)settings.unset(b3)settings.save(l._path)end,get=function(b3)return settings.get(b3)end}m={get_monitors=function(b4)local b5={}for d,b6 in next,b4 do if b6=="terminal"then b5[b6]=term else if peripheral.getType(b6)=="monitor"then b5[b6]=peripheral.wrap(b6)end end end;return b5 end,better_print=function(b7,b8,b9,...)local ba=g.join({...},"")local bb=b7.getTextColor()local bc=b7.getBackgroundColor()if b8 then b7.setTextColor(b8)end;if b9 then b7.setBackgroundColor(b9)end;print(ba)b7.setTextColor(bb)b7.setBackgroundColor(bc)end,better_clear=function(b7)b7.clear()b7.setCursorPos(1,1)end}local bd={frame={pixels={},background=nil},screens={terminal=term},clear_after_draw=true,buffer={pixels={},background=colors.black,is_pixel_custom=function(self,a5,a6)if self.pixels[a5]then if self.pixels[a5][a6]then return true end end;return false end,get_pixel=function(self,a5,a6)if self:is_pixel_custom(a5,a6)then return self.pixels[a5][a6]end;return{char=" ",foreground=self.background,background=self.background}end,set_pixel=function(self,a5,a6,O,b8,b9)a5,a6=math.floor(a5+0.5),math.floor(a6+0.5)local be=self:get_pixel(a5,a6)if O and#O==1 then be.char=O end;be.foreground=b8 or be.background;be.background=b9 or be.background;if not self.pixels[a5]then self.pixels[a5]={}end;self.pixels[a5][a6]=be end,clear=function(self)self.pixels={}end},set_screens=function(self,bf)self.screens=m.get_monitors(bf)end,set_monitors=function(self,b4)self:set_screens(b4)end,clear=function(self)self.buffer:clear()end,draw=function(self)local bg=self.screens;local bh=self.buffer;for bi,bj in next,bg do local bk,bl=bj.getCursorPos()local aZ,a_=bj.getSize()for a6=1,a_ do local bm={text="",background="",foreground=""}for a5=1,aZ do local be=bh:get_pixel(a5,a6)bm.text=bm.text..be.char;bm.background=bm.background..j.colors[be.background]bm.foreground=bm.foreground..j.colors[be.foreground]end;bj.setCursorPos(1,a6)bj.blit(bm.text,bm.foreground,bm.background)end;bj.setCursorPos(bk,bl)end;self.frame.pixels=self.buffer.pixels;self.frame.background=self.buffer.background;if self.clear_after_draw then self:clear()end end,point=function(self,a5,a6,aV)self.buffer:set_pixel(a5,a6," ",aV,aV)end,write=function(self,a5,a6,bn,b8,b9)for bo=0,#bn-1 do local O=bn:sub(bo+1,bo+1)self.buffer:set_pixel(a5+bo,a6,O,b8,b9)end end,blit=function(self,a5,a6,bn,b8,b9)local bp=""local bq=""b8=b8 or""b9=b9 or""for bo=0,#bn-1 do local O=bn:sub(bo+1,bo+1)local br=b8:sub(bo+1,bo+1)br=#br>0 and br or bp;local bs=b9:sub(bo+1,bo+1)bs=#bs>0 and bs or bq;self.buffer:set_pixel(a5+bo,a6,O,j.paint[br],j.paint[bs])bp=br;bq=bs end end,rectangle=function(self,a5,a6,aZ,a_,aV)for bo=0,aZ-1 do for bt=0,a_-1 do self:point(a5+bo,a6+bt,aV)end end end,line=function(self,bu,bv,bw,bx,aV)local function by(bu,bv,bw,bx)local bz=1;if bu>bw then bz=-1 end;local bA=bw-bu;local bB=bx-bv;local bC=1;if bB<0 then bC=-1;bB=-bB end;local bD=2*bB-bA;local a6=bv;for a5=bu,bw,bz do self:point(a5,a6,aV)if bD>0 then a6=a6+bC;bD=bD-2*bA end;bD=bD+2*bB end end;local function bE(bu,bv,bw,bx)local bz=1;if bv>bx then bz=-1 end;local bA=bw-bu;local bB=bx-bv;local bF=1;if bA<0 then bF=-1;bA=-bA end;local bD=2*bA-bB;local a5=bu;for a6=bv,bx,bz do self:point(a5,a6,aV)if bD>0 then a5=a5+bF;bD=bD-2*bB end;bD=bD+2*bA end end;if math.abs(bx-bv)<math.abs(bw-bu)then if bu>bw then by(bw,bx,bu,bv)else by(bu,bv,bw,bx)end else if bv>bx then bE(bw,bx,bu,bv)else bE(bu,bv,bw,bx)end end end,circle=function(self,bG,bH,bI,aV)local bJ=bI*bI;self:point(bG,bH+bI,aV)self:point(bG,bH-bI,aV)self:point(bG+bI,bH,aV)self:point(bG-bI,bH,aV)local a5=1;local a6=math.floor(math.sqrt(bJ-1)+0.5)while a5<a6 do self:point(bG+a5,bH+a6,aV)self:point(bG+a5,bH-a6,aV)self:point(bG-a5,bH+a6,aV)self:point(bG-a5,bH-a6,aV)self:point(bG+a6,bH+a5,aV)self:point(bG+a6,bH-a5,aV)self:point(bG-a6,bH+a5,aV)self:point(bG-a6,bH-a5,aV)a5=a5+1;a6=math.floor(math.sqrt(bJ-a5*a5)+0.5)end;if a5==a6 then self:point(bG+a5,bH+a6,aV)self:point(bG+a5,bH-a6,aV)self:point(bG-a5,bH+a6,aV)self:point(bG-a5,bH-a6,aV)end end}local bK={pressed_keys={},reset=function(self)self.pressed_keys={}end,is_key_pressed=function(self,bL,d)if self.pressed_keys[d]then if bL then self:remove_key(d)end;return true end;return false end,are_keys_pressed=function(self,bM,...)local keys={...}if not(#keys>0)then return false end;for bN,d in next,keys do if not self:is_key_pressed(false,d)then return false end end;if bM then self:remove_keys(table.unpack(keys))end;return true end,add_key=function(self,d)self.pressed_keys[d]=true end,remove_key=function(self,d)self.pressed_keys[d]=nil end,remove_keys=function(self,...)local keys={...}for bN,d in next,keys do self:remove_key(d)end end,manage_event=function(self,formatted_event)if formatted_event.name==b.KEY then self:add_key(formatted_event.key)elseif formatted_event.name==b.KEYUP then self:remove_key(formatted_event.key)end end}local bO={}bO={Clock={new=function(bP)local bQ={enabled=true,oneshot=false,clock=os.clock(),interval=bP,callbacks={onClock=function()end}}setmetatable(bQ,bO.Clock)return bQ end,event=function(self,formatted_event)if not self.enabled then self:reset_timer()return end;if os.clock()>=self.clock+self.interval then self:reset_timer()self.callbacks.onClock(self,formatted_event)if self.oneshot then self:stop()end end end,start=function(self)self:reset_timer()self.enabled=true end,stop=function(self)self.enabled=false end,reset_timer=function(self)self.clock=os.clock()end},Label={new=function(a5,a6,bn,b8,b9)local bR={draw_priority=b.LOW_PRIORITY,focussed=false,hidden=false,text_alignment=b.ALIGN_LEFT,text=bn,pos=h.Vector2.new(a5,a6),colors={foreground=b8,background=b9},callbacks={onDraw=function()end}}setmetatable(bR,bO.Label)return bR end,draw=function(self,bS)if self.hidden then return end;self.callbacks.onDraw(self,bS)local P=g.split_by_char(self.text,"\n")if self.text_alignment==b.ALIGN_LEFT then for d,bT in next,P do bd:write(self.pos.x,self.pos.y+d-1,bT,self.colors.foreground,self.colors.background)end elseif self.text_alignment==b.ALIGN_CENTER then for d,bT in next,P do bd:write(self.pos.x-#bT/2,self.pos.y+d-1,bT,self.colors.foreground,self.colors.background)end elseif self.text_alignment==b.ALIGN_RIGHT then for d,bT in next,P do bd:write(self.pos.x-#bT+1,self.pos.y+d-1,bT,self.colors.foreground,self.colors.background)end end end},Button={new=function(a5,a6,aZ,a_,bn,b8,bU,bV)local bW={draw_priority=b.LOW_PRIORITY,focussed=false,hidden=false,active=false,shortcut_once=true,shortcut={},text_alignment=b.ALIGN_CENTER,text=bn,pos=h.Vector2.new(a5,a6),size=h.Vector2.new(aZ,a_),timed={enabled=false,clock=bO.Clock.new(0.5)},colors={foreground=b8,active_background=bU,unactive_background=bV},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end,onTimeout=function()end}}bW.timed.clock.binded_button=bW;bW.timed.clock.oneshot=true;bW.timed.clock:stop()f.set_callback(bW.timed.clock,b.ONCLOCK,function(self,formatted_event)self.binded_button.active=false;self.binded_button.callbacks.onPress(self.binded_button,formatted_event)self.binded_button.callbacks.onTimeout(self.binded_button,formatted_event)end)setmetatable(bW,bO.Button)return bW end,draw=function(self,bS)if self.hidden then return end;self.callbacks.onDraw(self,bS)if self.active then bd:rectangle(self.pos.x,self.pos.y,self.size.x,self.size.y,self.colors.active_background)else bd:rectangle(self.pos.x,self.pos.y,self.size.x,self.size.y,self.colors.unactive_background)end;local P=g.split_by_char(self.text,"\n")local bX=(self.size.y-#P)/2+self.pos.y;for bt=0,#P-1 do local bT=P[bt+1]local bY;if self.text_alignment==b.ALIGN_LEFT then bY=self.pos.x elseif self.text_alignment==b.ALIGN_CENTER then bY=(self.size.x-#bT)/2+self.pos.x elseif self.text_alignment==b.ALIGN_RIGHT then bY=self.pos.x+self.size.x-#bT end;bd:write(bY,bX+bt,bT,self.colors.foreground)end end,event=function(self,formatted_event)if self.hidden then return false end;if formatted_event.name==b.TOUCH then if k.is_area_pressed(formatted_event.x,formatted_event.y,self.pos.x,self.pos.y,self.size.x,self.size.y)then self:press(formatted_event)return true else self.callbacks.onFailedPress(self,formatted_event)end elseif bK:are_keys_pressed(self.shortcut_once,table.unpack(self.shortcut))then self:press(formatted_event)end;if self.timed.enabled then self.timed.clock:event(formatted_event)end end,press=function(self,formatted_event)if self.timed.enabled then self.timed.clock:start()if not self.active then self.active=true;self.callbacks.onPress(self,formatted_event)end else self.active=not self.active;self.callbacks.onPress(self,formatted_event)end end},Progressbar={new=function(a5,a6,aZ,a_,bZ,al,am,b8,b_,c0)local c1={draw_priority=b.LOW_PRIORITY,focussed=false,hidden=false,active=false,pos=h.Vector2.new(a5,a6),size=h.Vector2.new(aZ,a_),value={max=am,min=al,current=bZ,draw_percentage=true,percentage_precision=2},colors={foreground=b8,filled_background=b_,unfilled_background=c0},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end}}setmetatable(c1,bO.Progressbar)return c1 end,draw=function(self,bS)if self.hidden then return end;self.callbacks.onDraw(self,bS)local c2=h.map(self.value.current,self.value.min,self.value.max,0,1,true)local c3=self.size.x*c2;bd:rectangle(self.pos.x,self.pos.y,c3,self.size.y,self.colors.filled_background)bd:rectangle(self.pos.x+c3,self.pos.y,self.size.x-c3,self.size.y,self.colors.unfilled_background)if self.value.draw_percentage then local c4=g.format_number(c2*100,self.value.percentage_precision).."%"local c5=(self.size.x-#c4)/2+self.pos.x;local bX=(self.size.y-1)/2+self.pos.y;bd:write(c5,bX,c4,self.colors.foreground)end end,event=function(self,formatted_event)if self.hidden then return false end;if formatted_event.name==b.TOUCH then if k.is_area_pressed(formatted_event.x,formatted_event.y,self.pos.x,self.pos.y,self.size.x,self.size.y)then self.callbacks.onPress(self,formatted_event)end end end,set=function(self,I)local c6=h.constrain(I,self.value.min,self.value.max)self.value.current=c6 end},Memo={new=function(a5,a6,aZ,a_,b8,b9)local c7={draw_priority=b.LOW_PRIORITY,focussed=false,hidden=false,pos=h.Vector2.new(a5,a6),size=h.Vector2.new(aZ,a_),editable=true,tab_spaces="  ",rich_text={},lines={},first_visible_line=1,first_visible_char=1,cursor={visible=false,text=" ",blink=bO.Clock.new(0.5),pos=h.Vector2.new(1,1)},limits=h.Vector2.new(0,0),whitelist={},blacklist={},colors={foreground=b8,background=b9,cursor=colors.white,cursor_text=colors.black},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end,onFocus=function()end,onKey=function()end,onChar=function()end,onMouseScroll=function()end,onCursorChange=function()end,onWrite=function()end}}c7.cursor.blink.binded_cursor=c7.cursor;f.set_callback(c7.cursor.blink,b.ONCLOCK,function(self,formatted_event)self.binded_cursor.visible=not self.binded_cursor.visible end)setmetatable(c7,bO.Memo)return c7 end,draw=function(self,bS)if self.hidden then return end;self.callbacks.onDraw(self,bS)bd:rectangle(self.pos.x,self.pos.y,self.size.x,self.size.y,self.colors.background)local c8=self.cursor.pos.x-self.first_visible_char;local c9=self.cursor.pos.y-self.first_visible_line;for a6=1,self.size.y do local ca=a6+self.first_visible_line-1;local cb=self.rich_text[ca]or{}local bT=self.lines[ca]or""local cc=self.first_visible_char;local cd=self.first_visible_char+self.size.x-1;local ce=bT:sub(cc,cd)local cf=self.pos.y+a6-1;if cb.background then if type(cb.background)=="string"then local cg=cb.background:sub(cc,cd)cg=#cg>0 and cg or cb.background:sub(#cb.background)bd:blit(self.pos.x,cf,string.rep(" ",self.size.x),nil,cg)else bd:rectangle(self.pos.x,cf,self.size.x,1,cb.background)end end;if cb.foreground then if type(cb.foreground)=="string"then local ch=cb.foreground:sub(cc,cd)ch=#ch>0 and ch or cb.foreground:sub(#cb.foreground)bd:blit(self.pos.x,cf,ce,ch)else bd:write(self.pos.x,cf,ce,cb.foreground)end else bd:write(self.pos.x,cf,ce,self.colors.foreground)end end;if self.cursor.visible and c8>=0 and c8<self.size.x and c9>=0 and c9<self.size.y then bd:write(c8+self.pos.x,c9+self.pos.y,self.cursor.text,self.colors.cursor_text,self.colors.cursor)end end,event=function(self,formatted_event)if self.hidden then return false end;if not self.editable then return false end;if formatted_event.name==b.TOUCH then if k.is_area_pressed(formatted_event.x,formatted_event.y,self.pos.x,self.pos.y,self.size.x,self.size.y)then self.callbacks.onPress(self,formatted_event)self:focus(true,formatted_event)local a5=formatted_event.x-self.pos.x;local a6=formatted_event.y-self.pos.y;self:set_cursor(a5+self.first_visible_char,a6+self.first_visible_line)return true else self.callbacks.onFailedPress(self,formatted_event)self:focus(false,formatted_event)return false end elseif formatted_event.name==b.DELETED then self:focus(false,formatted_event)return false end;if self.focussed then self.cursor.blink:event(self.cursor.blink,formatted_event)if formatted_event.name==b.PASTE then self:write(formatted_event.paste)return true elseif formatted_event.name==b.CHAR then if self.callbacks.onChar(self,formatted_event)then return true end;self:write(formatted_event.char)return true elseif formatted_event.name==b.KEY then if self.callbacks.onKey(self,formatted_event)then return true end;if bK:are_keys_pressed(false,b.KEY_LEFTALT,b.KEY_UP)then if self.cursor.pos.y>1 then local ci=self.lines[self.cursor.pos.y-1]local cj=self.lines[self.cursor.pos.y]self.lines[self.cursor.pos.y-1]=""table.remove(self.lines,self.cursor.pos.y)local bk=self.cursor.pos.x;self:set_cursor(1,self.cursor.pos.y-1)self:write(cj.."\n"..ci)self:set_cursor(bk,self.cursor.pos.y-1)end;return true elseif bK:are_keys_pressed(false,b.KEY_LEFTALT,b.KEY_DOWN)then local cj=self.lines[self.cursor.pos.y]local ck=self.lines[self.cursor.pos.y+1]if not ck then return false end;self.lines[self.cursor.pos.y]=""table.remove(self.lines,self.cursor.pos.y+1)local bk=self.cursor.pos.x;self:set_cursor(1,self.cursor.pos.y)self:write(ck.."\n"..cj)self:set_cursor(bk,self.cursor.pos.y)return true elseif formatted_event.key==b.KEY_UP then self:set_cursor(self.cursor.pos.x,self.cursor.pos.y-1)return true elseif formatted_event.key==b.KEY_DOWN then self:set_cursor(self.cursor.pos.x,self.cursor.pos.y+1)return true elseif formatted_event.key==b.KEY_RIGHT then local bT=self.lines[self.cursor.pos.y]if self.lines[self.cursor.pos.y+1]and self.cursor.pos.x>=#bT+1 then self:set_cursor(1,self.cursor.pos.y+1)else self:set_cursor(self.cursor.pos.x+1,self.cursor.pos.y)end;return true elseif formatted_event.key==b.KEY_LEFT then if self.cursor.pos.x<=1 and self.cursor.pos.y>1 then local cl=self.lines[self.cursor.pos.y-1]self:set_cursor(#cl+1,self.cursor.pos.y-1)else self:set_cursor(self.cursor.pos.x-1,self.cursor.pos.y)end;return true elseif formatted_event.key==b.KEY_BACKSPACE then local bT=self.lines[self.cursor.pos.y]if self.cursor.pos.x<=1 then if self.cursor.pos.y>1 then table.remove(self.lines,self.cursor.pos.y)local cm=#self.lines[self.cursor.pos.y-1]+1;local cn=self.cursor.pos.y-1;self:set_cursor(cm,cn)self:write(bT)self:set_cursor(cm,cn)end else local az=bT:sub(1,self.cursor.pos.x-2)..bT:sub(self.cursor.pos.x)self.lines[self.cursor.pos.y]=az;self:set_cursor(self.cursor.pos.x-1,self.cursor.pos.y)self.callbacks.onWrite(self,az,{az})end;return true elseif formatted_event.key==b.KEY_DELETE then local bT=self.lines[self.cursor.pos.y]local co=bT:sub(self.cursor.pos.x)if#co>0 then local az=bT:sub(1,self.cursor.pos.x-1)..bT:sub(self.cursor.pos.x+1)self.lines[self.cursor.pos.y]=az;self.callbacks.onWrite(self,az,{az})else local ck=self.lines[self.cursor.pos.y+1]if ck then local cm=self.cursor.pos.x;local cn=self.cursor.pos.y;table.remove(self.lines,self.cursor.pos.y+1)self:write(ck)self:set_cursor(cm,cn)end end;return true elseif formatted_event.key==b.KEY_ENTER then local cp=self.lines[self.cursor.pos.y]:sub(0,self.cursor.pos.x-1)local cq=cp:gsub("(%s*).*","%1")self:write("\n"..cq)return true elseif formatted_event.key==b.KEY_END then self:set_cursor(#self.lines[self.cursor.pos.y]+1,self.cursor.pos.y)return true elseif formatted_event.key==b.KEY_HOME then local cp=self.lines[self.cursor.pos.y]:sub(0,self.cursor.pos.x-1)local cq=cp:gsub("(%s*).*","%1")self:set_cursor(#cq+1,self.cursor.pos.y)return true elseif bK:are_keys_pressed(false,b.KEY_LEFTSHIFT,b.KEY_TAB)then local cr=self.lines[self.cursor.pos.y]local cq=cr:gsub("^(%s*).*$","%1")local cs=math.min(#self.tab_spaces,#cq)local az=cr:sub(cs+1)self.lines[self.cursor.pos.y]=az;self:set_cursor(self.cursor.pos.x-cs,self.cursor.pos.y)self.callbacks.onWrite(self,az,{az})return true elseif formatted_event.key==b.KEY_TAB then local bk=self.cursor.pos.x;local ct=#self.lines[self.cursor.pos.y]self:set_cursor(1,self.cursor.pos.y)self:write(self.tab_spaces)local cu=#self.lines[self.cursor.pos.y]-ct;self:set_cursor(bk+cu,self.cursor.pos.y)return true end elseif formatted_event.name==b.MOUSESCROLL then if self.callbacks.onMouseScroll(self,formatted_event)then return true end;self.first_visible_line=h.constrain(self.first_visible_line+formatted_event.direction,1,#self.lines)return true end end end,focus=function(self,cv,formatted_event)if cv then self.focussed=true;self.callbacks.onFocus(self,formatted_event)else self.focussed=false;self.cursor.visible=false;self.callbacks.onFocus(self,formatted_event)end end,set_cursor=function(self,cm,cn,cw)if not self.lines[1]then self.lines[1]=""end;if self.limits.y>0 then cn=h.constrain(cn,1,self.limits.y)end;if cw then for a6=#self.lines+1,cn do if not self.lines[a6]then self.lines[a6]=""end end else cn=h.constrain(cn,1,#self.lines)end;cm=h.constrain(cm,1,#self.lines[cn]+1)local c8=cm-self.first_visible_char;local c9=cn-self.first_visible_line;if c8>=self.size.x then self.first_visible_char=self.first_visible_char+c8-self.size.x+1 elseif c8<0 then self.first_visible_char=self.first_visible_char+c8 end;if c9>=self.size.y then self.first_visible_line=self.first_visible_line+c9-self.size.y+1 elseif c9<0 then self.first_visible_line=self.first_visible_line+c9 end;self.callbacks.onCursorChange(self,cm,cn)self.cursor.pos=h.Vector2.new(cm,cn)end,write=function(self,...)local bn=g.join({...},"")local P=g.split_by_char(bn,"\n")self:set_cursor(self.cursor.pos.x,self.cursor.pos.y,true)if#self.whitelist>0 then local K="[^"..g.escape_magic_characters(g.join(self.whitelist,"")).."]"for d,bT in next,P do P[d]=bT:gsub(K,"")end elseif#self.blacklist>0 then local K="["..g.escape_magic_characters(g.join(self.blacklist,"")).."]"for d,bT in next,P do P[d]=bT:gsub(K,"")end end;if self.limits.y>0 then for a6=1,#self.lines+#P-1-self.limits.y do table.remove(P)end;if#P==0 then return end end;if#P>1 then for cx,bT in next,P do if cx==1 then local cy=self.lines[self.cursor.pos.y]local cz=cy:sub(1,self.cursor.pos.x-1)local co=cy:sub(self.cursor.pos.x)local cA=P[#P]if self.limits.x>0 then bT=bT:sub(1,self.limits.x-#cz)cA=cA:sub(1,self.limits.x-#co)end;self.lines[self.cursor.pos.y]=cz..bT;table.insert(self.lines,self.cursor.pos.y+1,cA..co)self:set_cursor(#cA+1,self.cursor.pos.y+1)elseif cx==#P then break else if self.limits.x>0 then bT=bT:sub(1,self.limits.x)end;table.insert(self.lines,self.cursor.pos.y,bT)self:set_cursor(self.cursor.pos.x,self.cursor.pos.y+1)end end else local cy=self.lines[self.cursor.pos.y]local cz=cy:sub(1,self.cursor.pos.x-1)local co=cy:sub(self.cursor.pos.x)if self.limits.x>0 then P[1]=P[1]:sub(1,self.limits.x-(#cz+#co))end;self.lines[self.cursor.pos.y]=cz..P[1]..co;self:set_cursor(self.cursor.pos.x+#P[1],self.cursor.pos.y)end;self.callbacks.onWrite(self,bn,P)end,print=function(self,...)local bn=g.join({...},"")local az=#self.lines>0 and"\n"or""self:write(az..bn)end,clear=function(self)self.lines={}self.callbacks.onCursorChange(self,1,1)self.cursor.pos=h.Vector2.new(1,1)end},Window={new=function(a5,a6,aZ,a_,b9,cB)local cC={draw_priority=b.HIGH_PRIORITY,focussed=false,hidden=false,pos=h.Vector2.new(a5,a6),size=h.Vector2.new(aZ,a_),can_drag=false,dragging={enabled=true,from=h.Vector2.new(1,1)},resizing={enabled=true,corner=h.Vector2.new(-1,1),enabled_directions={[-1]={[1]=true,[0]=true,[-1]=true},[0]={[1]=true,[0]=false,[-1]=true},[1]={[1]=true,[0]=true,[-1]=true}},pinned={x=false,y=false},min_size=h.Vector2.new(aZ,a_),max_size=h.Vector2.new(aZ,a_)*2},shadow={enabled=cB,offset=h.Vector2.new(1,1)},elements={},colors={background=b9,shadow=colors.black},callbacks={onDraw=function()end,onPress=function()end,onFailedPress=function()end,onFocus=function()end,onDrag=function()end,onResize=function()end}}setmetatable(cC,bO.Window)return cC end,draw=function(self,bS)if self.hidden then return end;self.callbacks.onDraw(self,bS)if self.shadow.enabled then bd:rectangle(self.pos.x+self.shadow.offset.x,self.pos.y+self.shadow.offset.y,self.size.x,self.size.y,self.colors.shadow)end;bd:rectangle(self.pos.x,self.pos.y,self.size.x,self.size.y,self.colors.background)self:draw_elements(bS)end,event=function(self,formatted_event)if self.hidden then return false end;local cD=self:event_elements(formatted_event)if not cD then if formatted_event.name==b.TOUCH then if k.is_area_pressed(formatted_event.x,formatted_event.y,self.pos.x,self.pos.y,self.size.x,self.size.y)then self.can_drag=false;if self.resizing.enabled then local cE=true;local cF=formatted_event.y==self.pos.y+self.size.y-1;local cG=formatted_event.y==self.pos.y;if formatted_event.x==self.pos.x+self.size.x-1 then if self.resizing.enabled_directions[1][1]and cF then self.resizing.corner=self.pos.ONE:duplicate()self.resizing.pinned.x=false;self.resizing.pinned.y=false elseif self.resizing.enabled_directions[1][-1]and cG then self.resizing.corner=self.pos.UP+self.pos.RIGHT;self.resizing.pinned.x=false;self.resizing.pinned.y=false elseif self.resizing.enabled_directions[1][0]and not(cF or cG)then self.resizing.corner=self.pos.UP+self.pos.RIGHT;self.resizing.pinned.x=false;self.resizing.pinned.y=true else cE=false end elseif formatted_event.x==self.pos.x then if self.resizing.enabled_directions[-1][1]and cF then self.resizing.corner=self.pos.DOWN+self.pos.LEFT;self.resizing.pinned.x=false;self.resizing.pinned.y=false elseif self.resizing.enabled_directions[-1][-1]and cG then self.resizing.corner=self.pos.ONE*-1;self.resizing.pinned.x=false;self.resizing.pinned.y=false elseif self.resizing.enabled_directions[-1][0]and not(cF or cG)then self.resizing.corner=self.pos.ONE*-1;self.resizing.pinned.x=false;self.resizing.pinned.y=true else cE=false end elseif self.resizing.enabled_directions[0][1]and cF then self.resizing.corner=self.pos.DOWN+self.pos.RIGHT;self.resizing.pinned.x=true;self.resizing.pinned.y=false elseif self.resizing.enabled_directions[0][-1]and cG then self.resizing.corner=self.pos.UP+self.pos.RIGHT;self.resizing.pinned.x=true;self.resizing.pinned.y=false else cE=false end;if not cE then self.resizing.corner=self.pos.ZERO:duplicate()self.dragging.from=h.Vector2.new(formatted_event.x,formatted_event.y)self.can_drag=self.dragging.enabled and true end else self.dragging.from=h.Vector2.new(formatted_event.x,formatted_event.y)self.can_drag=self.dragging.enabled and true end;self.focussed=true;self.callbacks.onPress(self,formatted_event)self.callbacks.onFocus(self,formatted_event)return true else self.focussed=false;self.callbacks.onFailedPress(self,formatted_event)self.callbacks.onFocus(self,formatted_event)end elseif formatted_event.name==b.MOUSEDRAG and self.focussed then if self.can_drag then self:drag(formatted_event.x,formatted_event.y)else self:resize(formatted_event.x,formatted_event.y,self.resizing.pinned.x,self.resizing.pinned.y)end;return true elseif formatted_event.name==b.DELETED then self.focussed=false;self.callbacks.onFocus(self,formatted_event)end else self.focussed=false;self.callbacks.onFocus(self,formatted_event)end;return cD end,drag=function(self,a5,a6)if self.dragging.enabled then local cH=self.pos:duplicate()local cI=h.Vector2.new(a5-self.dragging.from.x,a6-self.dragging.from.y)self.pos=self.pos+cI;self.dragging.from=h.Vector2.new(a5,a6)self.callbacks.onDrag(self,cH.x,cH.y)end end,resize=function(self,a5,a6,cJ,cK)if self.resizing.enabled and self.resizing.corner~=self.pos.ZERO then local function cL()self.size.x=h.constrain(self.size.x,self.resizing.min_size.x,self.resizing.max_size.x)self.size.y=h.constrain(self.size.y,self.resizing.min_size.y,self.resizing.max_size.y)end;local cM=h.Vector2.new(a5,a6)local cH=self.pos:duplicate()local cN=self.size:duplicate()if self.resizing.corner==self.pos.ONE then self.size=cM-self.pos+self.pos.ONE;cL()elseif self.resizing.corner==self.pos.ONE*-1 then self.size=self.size+self.pos-cM;cL()local cO=cN-self.size;self.pos=self.pos+cO elseif self.resizing.corner==self.pos.UP+self.pos.RIGHT then self.size.x=cM.x-self.pos.x+1;self.size.y=self.size.y+self.pos.y-cM.y;cL()local cP=cN.y-self.size.y;self.pos.y=self.pos.y+cP elseif self.resizing.corner==self.pos.DOWN+self.pos.LEFT then local cQ=self.size.x;self.size.x=self.size.x+self.pos.x-cM.x;self.size.y=cM.y-self.pos.y+1;cL()local cu=cN.x-self.size.x;self.pos.x=self.pos.x+cu end;if cJ then self.size.x=cN.x;self.pos.x=cH.x end;if cK then self.size.y=cN.y;self.pos.y=cH.y end;self.callbacks.onResize(self,cH.x,cH.y,cN.x,cN.y)end end,set_elements=function(self,cR)self.elements={}for d,cS in next,cR do table.insert(self.elements,cS)end end,draw_elements=function(self,bS)for d=#self.elements,1,-1 do local cS=self.elements[d]if cS.draw then cS.pos=cS.pos+self.pos-self.pos.ONE;cS:draw(bS)cS.pos=cS.pos-self.pos+self.pos.ONE end end end,event_elements=function(self,formatted_event)local cT=formatted_event;if cT.name==b.TOUCH then cT=k.format_event_table(cT.raw)cT.x,cT.y=cT.x-self.pos.x+1,cT.y-self.pos.y+1 end;local cD=false;for d,cS in next,self.elements do if cS.event then local cU=cS:event(cT)cD=cD or cU;if cU then cT={name=b.DELETED}end end end;return cD end}}bO.Clock.__index=bO.Clock;bO.Label.__index=bO.Label;bO.Button.__index=bO.Button;bO.Progressbar.__index=bO.Progressbar;bO.Memo.__index=bO.Memo;bO.Window.__index=bO.Window;local cV={}cV={new=function(cW)local cX={draw_priority=b.LOW_PRIORITY,enabled=false,buffer={},events_whitelist={[b.TOUCH]=true,[b.KEY]=true,[b.KEYUP]=true,[b.CHAR]=true,[b.MOUSEDRAG]=true,[b.MOUSESCROLL]=true,[b.MOUSEUP]=true},close_on_host_disconnect=true,side=b.NONE,mode=b.NONE,host_id=b.NONE,users={},protocol="YAGUI-"..a.ver.."_WSS",broadcast_clock=bO.Clock.new(cW or 4),callbacks={onDraw=function()end,onEvent=function()end,onConnect=function()end,onDisconnect=function()end}}cX.broadcast_clock.WSS=cX;f.set_callback(cX.broadcast_clock,b.ONCLOCK,function(self,formatted_event)rednet.broadcast(bd.frame,self.WSS.protocol)end)setmetatable(cX,cV)return cX end,draw=function(self,bS)if not self.enabled then return false end;self.callbacks.onDraw(self,bS)if self.mode==b.USER then if self.buffer and self.buffer.background and self.buffer.pixels then bd.buffer.background=self.buffer.background;bd.buffer.pixels=self.buffer.pixels end end end,event=function(self,formatted_event)if not self.enabled then return false end;if self.callbacks.onEvent(self,formatted_event)then return true end;local cY=false;if formatted_event.name==b.REDNET then if formatted_event.protocol==self.protocol then local b2=formatted_event.message;if self.mode==b.HOST then if b2==b.CONNECTION_REQUEST then rednet.send(formatted_event.from,b.OK,self.protocol)self.users[formatted_event.from]=true;cY=true;self.callbacks.onConnect(self,formatted_event)elseif b2==b.DISCONNECTED then self.users[formatted_event.from]=nil;cY=true;self.callbacks.onDisconnect(self,formatted_event)elseif self.events_whitelist[b2.name or"nil"]and self.users[formatted_event.from]and type(b2)=="table"then if b2.raw then os.queueEvent(table.unpack(b2.raw))end;cY=true end elseif self.mode==b.USER then if formatted_event.from==self.host_id then if b2==b.DISCONNECTED then if self.close_on_host_disconnect then self:close()end;cY=true;self.callbacks.onDisconnect(self,formatted_event)elseif type(b2)=="table"then self.buffer=b2;cY=true end end end end end;if self.mode==b.USER then if formatted_event.name==b.TOUCH then cY=true end;if self.events_whitelist[tostring(formatted_event.name)]then rednet.send(self.host_id,formatted_event,self.protocol)cY=true end elseif self.mode==b.HOST then self.broadcast_clock:event(formatted_event)end;return cY end,use_side=function(self,cZ)self.side=cZ end,connect=function(self,c_,d0,d1)d0=d0 or 2;d1=d1 or 10;rednet.open(self.side)self.host_id=c_;self.mode=b.USER;rednet.send(self.host_id,b.CONNECTION_REQUEST,self.protocol)local d2=0;while true do d2=d2+1;local d3={rednet.receive(self.protocol,d0)}if d3[1]==c_ and d3[2]==b.OK and d3[3]==self.protocol then return b.OK elseif d2>=d1 then local d4=string.format("Connection timed out on attempt %d after %d ms",d2,d0*1000)if#d3>0 then d4=string.format("Connection timed out on attempt %d: invalid response (The traffic on the network may be high, try to increase max attempts)",d2,d0*1000)end;cV:close()error(d4,2)end end;self.callbacks.onConnect(self,c_)end,host=function(self)rednet.open(self.side)self.host_id=os.getComputerID()self.mode=b.HOST end,close=function(self)if rednet.isOpen()then if self.mode==b.HOST then rednet.broadcast(b.DISCONNECTED,self.protocol)elseif self.mode==b.USER then rednet.send(self.host_id,b.DISCONNECTED,self.protocol)end;rednet.close(self.side)end;self.host_id=b.NONE;self.mode=b.NONE end}cV.__index=cV;local d5={}d5={new=function(d6)local d7={enabled=true,computer_whitelist={},side=b.NONE,mode=b.ALL,password=d6 or b.NONE,protocol="YAGUI-"..a.ver.."_FT",save_dir="/FT",callbacks={onEvent=function()end,onConnect=function()end,onSend=function()end,onReceive=function()end}}setmetatable(d7,d5)return d7 end,event=function(self,formatted_event)if not self.enabled then return false end;if self.callbacks.onEvent(self,formatted_event)then return true end;if formatted_event.name==b.REDNET and formatted_event.protocol==self.protocol then if self.mode==b.ALL or self.mode==b.RECEIVE then local c_=formatted_event.from;if self.computer_whitelist[c_]or self.callbacks.onConnect(self,formatted_event)then local b2=formatted_event.message;if type(b2)=="table"and b2.name and b2.content then if b2.psw==self.password then local b3=fs.getName(tostring(b2.name))local Y=fs.combine(self.save_dir,b3)if fs.exists(Y)then rednet.send(c_,b.NO,self.protocol)else local d8=tostring(b2.content)if self.callbacks.onReceive(self,formatted_event,c_,b3,Y,d8)then return true end;local d9=fs.open(Y,"w")if d9 then d9.write(d8)d9.close()rednet.send(c_,b.OK,self.protocol)else rednet.send(c_,b.ERROR,self.protocol)end end else rednet.send(c_,b.NO,self.protocol)end else rednet.send(c_,b.ERROR,self.protocol)end else rednet.send(c_,b.NO,self.protocol)end end end end,send=function(self,da,db,dc,dd)if self.mode==b.ALL or self.mode==b.SEND then dd=dd or fs.getName(dc)db=db or b.NONE;local d9=fs.open(dc,"r")local d8=d9.readAll()d9.close()local b2={psw=db,name=dd,content=d8}if self.callbacks.onSend(self,formatted_event,b2)then return true end;rednet.send(da,b2,self.protocol)end end,open=function(self,cZ)self.side=cZ;rednet.open(cZ)end,close=function(self)if rednet.isOpen()then rednet.close(self.side)end end}d5.__index=d5;local de={}de={new=function(df,dg)local dh={enabled=false,options={raw_mode=false,stop_on_terminate=true,FPS_target=df,EPS_target=dg},monitors={terminal=term},elements={high_priority={},low_priority={},loop={clock=bO.Clock.new(1/df),stats_clock=bO.Clock.new(1),FPS_label=bO.Label.new(1,1,"1 FPS",colors.white),EPS_label=bO.Label.new(1,2,"1 EPS",colors.white)}},stats={pos=h.Vector2.new(1,1),elements=nil,show=function(self,di)self.elements.FPS_label.hidden=not di;self.elements.EPS_label.hidden=not di end,update_pos=function(self)self.elements.FPS_label.pos=self.pos;self.elements.EPS_label.pos=self.pos+h.Vector2.DOWN end,Frames=0,Events=0,FPS=0,EPS=0},callbacks={onStart=function()end,onStop=function()end,onDraw=function()end,onClock=function()end,onEvent=function()end}}dh.elements.loop.stats_clock.stats=dh.stats;dh.stats.elements=dh.elements.loop;f.set_callback(dh.elements.loop.stats_clock,b.ONCLOCK,function(self,formatted_event)self.stats:update_pos()self.stats.elements.FPS_label.text=tostring(self.stats.FPS).." FPS"self.stats.elements.EPS_label.text=tostring(self.stats.EPS).." EPS"self.stats.FPS,self.stats.EPS=self.stats.Frames,self.stats.Events;self.stats.Frames,self.stats.Events=0,0 end)dh.stats:show(false)dh.elements.loop.clock.Loop=dh;f.set_callback(dh.elements.loop.clock,b.ONCLOCK,function(self,formatted_event)self.Loop.callbacks.onClock(self.Loop,formatted_event)self.Loop:draw_elements(1/self.Loop.stats.FPS)self.interval=1/self.Loop.options.FPS_target end)setmetatable(dh,de)return dh end,set_monitors=function(self,b4)self.monitors=m.get_monitors(b4)end,set_elements=function(self,cR)self.elements.high_priority={}self.elements.low_priority={}for d,I in next,cR do if I.draw_priority==b.HIGH_PRIORITY then table.insert(self.elements.high_priority,I)else table.insert(self.elements.low_priority,I)end end end,draw_elements=function(self,bS)local function dj(F)for d=#F,1,-1 do local cS=F[d]if cS.draw then cS:draw(bS)end end end;self.callbacks.onDraw(self,bS)local dk=bd.screens;bd.screens=self.monitors;dj(self.elements.low_priority)dj(self.elements.high_priority)for d,cS in next,self.elements.loop do if cS.draw then cS:draw(bS)end end;bd:draw()bd.screens=dk;self.stats.Frames=self.stats.Frames+1 end,event_elements=function(self,formatted_event)local function b0(F)for d,cS in next,F do if cS.event then if cS:event(formatted_event)then formatted_event={name=b.DELETED}end end end end;if self.callbacks.onEvent(self,formatted_event)then formatted_event={name=b.DELETED}end;if self.options.stop_on_terminate and formatted_event.name==b.TERMINATE then self:stop()return end;if formatted_event.name==b.TOUCH then local dl=false;for dm,b7 in next,self.monitors do if formatted_event.from==dm then dl=true;break end end;if not dl then formatted_event={name=b.DELETED}end end;b0(self.elements.loop)local dn={}for d,cS in next,self.elements.high_priority do if cS.event then local dp=cS:event(formatted_event)if dp then formatted_event={name=b.DELETED}if self.elements.high_priority~=cS then table.insert(dn,{element=cS,key=d})end end end end;if#dn>0 then for d,I in next,dn do table.insert(self.elements.high_priority,1,I.element)table.remove(self.elements.high_priority,I.key+#dn)end end;b0(self.elements.low_priority)self.stats.Events=self.stats.Events+1 end,start=function(self)self.enabled=true;bK:reset()self.stats:update_pos()self.callbacks.onStart(self)while self.enabled do local dq=os.startTimer(1/self.options.EPS_target)local dr;if self.options.raw_mode then dr={os.pullEventRaw()}else dr={os.pullEvent()}end;local formatted_event=k.format_event_table(dr)bK:manage_event(formatted_event)self:event_elements(formatted_event)os.cancelTimer(dq)end;bK:reset()self.callbacks.onStop(self)end,stop=function(self)self.enabled=false end}de.__index=de;setmetatable(h.Vector2,e)setmetatable(h.Vector3,e)setmetatable(cV,e)setmetatable(d5,e)for d,cS in next,bO do setmetatable(cS,e)end;setmetatable(de,e)local ds={...}if ds[1]=="help"then local P={{text="LIBFILE <COMMAND>",foreground=colors.green,background=nil},{text=" - help (shows this list of commands)",foreground=colors.blue,background=nil},{text=" - info (prints info about the lib)",foreground=colors.yellow,background=nil},{text=" - ver (prints version of the lib)",foreground=colors.green,background=nil},{text=" - copyright (prints copyright of the lib)",foreground=colors.blue,background=nil},{text=" - setup (adds YAGUI_PATH to computer's settings)",foreground=colors.yellow,background=nil},{text=" - create <PATH> (creates a new YAGUI project)",foreground=colors.green,background=nil}}for d,bT in next,P do m.better_print(term,bT.foreground,bT.background,bT.text)end elseif ds[1]=="info"then m.better_print(term,colors.red,nil,"Library Version: ",a.ver)m.better_print(term,colors.yellow,nil,"Library Author: ",a.author)m.better_print(term,colors.green,nil,"Library Website: ",a.website)m.better_print(term,colors.blue,nil,"Library Documentation: ",a.documentation)elseif ds[1]=="ver"then m.better_print(term,colors.red,nil,"Library Version: ",a.ver)elseif ds[1]=="copyright"then local dt={colors.red,colors.yellow,colors.green}local du=g.split(a.copyright,"\n\n")for d,dv in next,du do m.better_print(term,dt[d],nil,dv)if d<#du then read("")end end elseif ds[1]=="setup"then if shell then local dw="YAGUI_PATH"local Y="/"..shell.getRunningProgram()l.set(dw,Y)m.better_print(term,colors.green,nil,"Lib path was set to \"",l.get(dw),"\".")else m.better_print(term,colors.red,nil,"SHELL API ISN'T AVAILABLE!")end elseif ds[1]=="create"then if ds[2]then local Y=shell.resolve(ds[2])if g.get_extension(Y)~="lua"then Y=Y..".lua"end;if fs.exists(Y)then m.better_print(term,colors.red,nil,"PATH: \"/",Y,"\" already exists, please use another path or delete it.")else local d9=fs.open(Y,"w")d9.write("\n-- AUTO-GENERATED with \"YAGUI create\"\nlocal YAGUI_PATH = settings.get(\"YAGUI_PATH\")\nif not (type(YAGUI_PATH) == \"string\") then printError(\"YAGUI is not installed, please install it by opening it with argument \\\"setup\\\".\"); return; end\nif not fs.exists(YAGUI_PATH) then printError(\"Couldn't find YAGUI in path: \\\"\"..YAGUI_PATH..\"\\\", Please reinstall it by opening it with argument \\\"setup\\\".\"); return; end\nlocal YAGUI = dofile(YAGUI_PATH)\n-- End of AUTO-GENERATED code\n\n")d9.close()m.better_print(term,colors.green,nil,"New project was created at \"/",Y,"\".")end else m.better_print(term,colors.red,nil,"You must specify a path to create a new project.")end elseif ds[1]then m.better_print(term,colors.red,nil,"UNKNOWN COMMAND: \"",ds[1],"\"")m.better_print(term,colors.green,nil,"Use \"help\" to get a list of available commands!")end;local dx={info=a,generic_utils=f,string_utils=g,math_utils=h,table_utils=i,color_utils=j,event_utils=k,setting_utils=l,monitor_utils=m,screen_buffer=bd,input=bK,WSS=cV,wireless_screen_share=cV,FT=d5,file_transfer=d5,gui_elements=bO,Loop=de}for d,I in next,b do dx[d]=I end;return dx