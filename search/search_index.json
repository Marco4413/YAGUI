{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to YAGUI Documentation v0.9 What does YAGUI stand for? YAGUI stands for \" Yet Another Graphical User Interface \", this library tries to make GUIs easier to make and more powerful by having these objectives : Has a Loop that makes easier event management ; Can draw and get events from multiple monitors ; Has a screen buffer which makes possible to simulate transparency when drawing; Has a rednet based wireless screen sharing system (Wireless Screen Share, WSS). Library Versions Versions of the library follow this format : M.m.b M: Major , you should probably rewrite most of your program to get it to work with the new version. m: Minor , look at the commit description and see if something that was used in your program has changed and check if it still works fine . b: Bug fixes , your program works as well as it worked on the last update . Terminal Arguments Terminal arguments are options with which you can launch the library to get information or make a new project easily. help Prints a list of available Terminal Arguments . info Prints informations about the library . ver Prints the version of the library . copyright Prints library's copyright . setup Sets up the library by creating a new CraftOS's setting which stores the path to the library , should be used every time you move the library and the first time you download it . create <PATH> Creates a new YAGUI project at PATH , a new project contains the code needed to load the library . Download & Installation There are two main ways of downloading the library : Downloading it from Raw GitHub using wget . Running pastebin run 5qQ6t6ZX on the terminal. By doing it with the first method you just download the library , by doing it with the second one you also get some examples to try as soon as you've set up the library. After you've downloaded it you should run it with setup argument to install it . Library Syntax You should probably know how to load the library , you can use either dofile or require , so you should put the name of the variable where you've stored the library in front of everything that you need to access from it separated with a . (e.g. YAGUI.KEY_UP ). Everything in the library is snake_cased (e.g. string_utils ), except for \"classes\" that are CamelCased (e.g. Loop ), callbacks that are lowerCamelCased (e.g. Loop.callbacks.onClock ) and constants that are UPPERCASED (e.g. ONCLOCK ) or SCREAMING_SNAKE_CASED (e.g. KEY_UP ). Most of the functions of the library need to be called like this table:function() or table.function(table) , except for functions that are in tables that have \"_utils\" at the end of their name.","title":"Introduction"},{"location":"#welcome-to-yagui-documentation-v09","text":"What does YAGUI stand for? YAGUI stands for \" Yet Another Graphical User Interface \", this library tries to make GUIs easier to make and more powerful by having these objectives : Has a Loop that makes easier event management ; Can draw and get events from multiple monitors ; Has a screen buffer which makes possible to simulate transparency when drawing; Has a rednet based wireless screen sharing system (Wireless Screen Share, WSS).","title":"Welcome to YAGUI Documentation v0.9"},{"location":"#library-versions","text":"Versions of the library follow this format : M.m.b M: Major , you should probably rewrite most of your program to get it to work with the new version. m: Minor , look at the commit description and see if something that was used in your program has changed and check if it still works fine . b: Bug fixes , your program works as well as it worked on the last update .","title":"Library Versions"},{"location":"#terminal-arguments","text":"Terminal arguments are options with which you can launch the library to get information or make a new project easily. help Prints a list of available Terminal Arguments . info Prints informations about the library . ver Prints the version of the library . copyright Prints library's copyright . setup Sets up the library by creating a new CraftOS's setting which stores the path to the library , should be used every time you move the library and the first time you download it . create <PATH> Creates a new YAGUI project at PATH , a new project contains the code needed to load the library .","title":"Terminal Arguments"},{"location":"#download-installation","text":"There are two main ways of downloading the library : Downloading it from Raw GitHub using wget . Running pastebin run 5qQ6t6ZX on the terminal. By doing it with the first method you just download the library , by doing it with the second one you also get some examples to try as soon as you've set up the library. After you've downloaded it you should run it with setup argument to install it .","title":"Download &amp; Installation"},{"location":"#library-syntax","text":"You should probably know how to load the library , you can use either dofile or require , so you should put the name of the variable where you've stored the library in front of everything that you need to access from it separated with a . (e.g. YAGUI.KEY_UP ). Everything in the library is snake_cased (e.g. string_utils ), except for \"classes\" that are CamelCased (e.g. Loop ), callbacks that are lowerCamelCased (e.g. Loop.callbacks.onClock ) and constants that are UPPERCASED (e.g. ONCLOCK ) or SCREAMING_SNAKE_CASED (e.g. KEY_UP ). Most of the functions of the library need to be called like this table:function() or table.function(table) , except for functions that are in tables that have \"_utils\" at the end of their name.","title":"Library Syntax"},{"location":"About/LICENSE/","text":"COPYRIGHT NOTICE Copyright (c) 2019, hds536jhmk : https://github.com/hds536jhmk/YAGUI Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"About"},{"location":"About/LICENSE/#copyright-notice","text":"Copyright (c) 2019, hds536jhmk : https://github.com/hds536jhmk/YAGUI Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"COPYRIGHT NOTICE"},{"location":"Modules/","text":"What are Modules? Well... Modules are basically all the tables that make the library (e.g. string_utils , math_utils ) Why Modules/Tables? I chose to use tables for these reasons: It's easier to make dofile/require work on the library's end . It's way more intuitive than having functions directly in the library (e.g. I want to do something with a string, oh wait there's string_utils , maybe that can help me). Better organized . I don't think there's a fourth point... But there's for sure a fifth point: This documentation will be much easier to organize . All the modules that are available There are currently 16 modules available, where 1 is dumped into the library and 1 is a duplicate of another one: info : Contains all informations about the library ( version , copyright , docs , ...). const : This is the one that's dumped into the library and contains all available constants that you can use to make future proofing easier. generic_utils : This contains functions that could be moved into another Module if another function that's similar to one of them is made, it has functions that haven't got their own group yet . string_utils : Contains all functions that are helpful when dealing with strings (e.g. split , join ). math_utils : Contains all functions that are helpful when dealing with numbers (e.g. Vector2 , map ). table_utils : Contains all function that are helpful when dealing with tables (e.g. has_value , has_key ). color_utils : You won't probably use this when making you first program , because this one was made to convert a color from Colors API into a string that can be used with monitor.blit , so it's just used by the library to draw on the screen faster, everything that asks you a color wants a color from the Colors API . event_utils : Contains all functions that are helpful when dealing with events , like formatting one ... That is needed for all event functions for making a GUI work (a \"raw event\" is local raw_event = {os.pullEvent()} , and all event functions want a formatted one local formatted_event = event_utils.format_event_table(raw_event) ). setting_utils : Have you ever needed to make changes in CraftOS's settings \"permanent\" ? Well this one is what you were looking for it has set , unset , get , and all the ones that change something in the settings will save a file that will automatically be loaded by CraftOS on boot , so settings changes are permanent as long as the file doesn't get deleted. monitor_utils : This isn't related to screen_buffer by any means , they usually aren't used in combo with that out of the way, this contains all functions that make managing monitors easier (e.g. better_print , better_clear ). screen_buffer : It's a screen buffer that lets you draw things on it and draw it to the screen (or multiple screens). input : This module contains all functions that can help you with keyboard input . It has a table which contains keycodes that are pressed, this doesn't work by itself but it has functions to add, remove and check keys (if you're using a Loop it's already managed by it). WSS : This module helps with screen sharing by broadcasting on a rednet protocol a table which contains screen_buffer.buffer.pixels and screen_buffer.buffer.background and it also has functions to connect to a WSS Server and replace the computer's buffer with the one received (doesn't draw automatically, you would need to do screen_buffer:draw() after having received the buffer to draw on screen). wireless_screen_share : Duplicate of WSS. gui_elements : Contains all elements that make a GUI (e.g. Button , Progressbar ). Loop : A loop that automatically manages specified gui_elements by giving them events and drawing them to the screen, also manages screen_buffer (it just draws it when it's done drawing the elements, so you can draw things on the screen and see the effects. Note that elements are always on top of what you draw if you draw stuff on onEvent and onClock Loop callbacks) and input modules .","title":"Introduction"},{"location":"Modules/#what-are-modules","text":"Well... Modules are basically all the tables that make the library (e.g. string_utils , math_utils )","title":"What are Modules?"},{"location":"Modules/#why-modulestables","text":"I chose to use tables for these reasons: It's easier to make dofile/require work on the library's end . It's way more intuitive than having functions directly in the library (e.g. I want to do something with a string, oh wait there's string_utils , maybe that can help me). Better organized . I don't think there's a fourth point... But there's for sure a fifth point: This documentation will be much easier to organize .","title":"Why Modules/Tables?"},{"location":"Modules/#all-the-modules-that-are-available","text":"There are currently 16 modules available, where 1 is dumped into the library and 1 is a duplicate of another one: info : Contains all informations about the library ( version , copyright , docs , ...). const : This is the one that's dumped into the library and contains all available constants that you can use to make future proofing easier. generic_utils : This contains functions that could be moved into another Module if another function that's similar to one of them is made, it has functions that haven't got their own group yet . string_utils : Contains all functions that are helpful when dealing with strings (e.g. split , join ). math_utils : Contains all functions that are helpful when dealing with numbers (e.g. Vector2 , map ). table_utils : Contains all function that are helpful when dealing with tables (e.g. has_value , has_key ). color_utils : You won't probably use this when making you first program , because this one was made to convert a color from Colors API into a string that can be used with monitor.blit , so it's just used by the library to draw on the screen faster, everything that asks you a color wants a color from the Colors API . event_utils : Contains all functions that are helpful when dealing with events , like formatting one ... That is needed for all event functions for making a GUI work (a \"raw event\" is local raw_event = {os.pullEvent()} , and all event functions want a formatted one local formatted_event = event_utils.format_event_table(raw_event) ). setting_utils : Have you ever needed to make changes in CraftOS's settings \"permanent\" ? Well this one is what you were looking for it has set , unset , get , and all the ones that change something in the settings will save a file that will automatically be loaded by CraftOS on boot , so settings changes are permanent as long as the file doesn't get deleted. monitor_utils : This isn't related to screen_buffer by any means , they usually aren't used in combo with that out of the way, this contains all functions that make managing monitors easier (e.g. better_print , better_clear ). screen_buffer : It's a screen buffer that lets you draw things on it and draw it to the screen (or multiple screens). input : This module contains all functions that can help you with keyboard input . It has a table which contains keycodes that are pressed, this doesn't work by itself but it has functions to add, remove and check keys (if you're using a Loop it's already managed by it). WSS : This module helps with screen sharing by broadcasting on a rednet protocol a table which contains screen_buffer.buffer.pixels and screen_buffer.buffer.background and it also has functions to connect to a WSS Server and replace the computer's buffer with the one received (doesn't draw automatically, you would need to do screen_buffer:draw() after having received the buffer to draw on screen). wireless_screen_share : Duplicate of WSS. gui_elements : Contains all elements that make a GUI (e.g. Button , Progressbar ). Loop : A loop that automatically manages specified gui_elements by giving them events and drawing them to the screen, also manages screen_buffer (it just draws it when it's done drawing the elements, so you can draw things on the screen and see the effects. Note that elements are always on top of what you draw if you draw stuff on onEvent and onClock Loop callbacks) and input modules .","title":"All the modules that are available"},{"location":"Modules/Vectors/","text":"Vectors Note that because they're objects all their methods except for new need to be called with \":\" between the object and the method (e.g. v:length() ). Vector2 Vector2 is a 2D vector object . Vector2 Constants It's got six constants that are pre-defined vectors : key x y ONE 1 1 UP 0 -1 DOWN 0 1 LEFT -1 0 RIGHT 1 0 ZERO 0 0 Vector2 Methods Vector2 : new ( number : x , number : y ) Returns a new Vector2 that points to ( x ; y ) . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing the vector (Note: tostring(v1) will return v1:string(0), -- if you want more precision you should use v1:string(decimal_digits)) print(v1) Vector2 : duplicate () Returns a new Vector2 that has the same x, y as the original Vector2 . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a reference to v1 local v2 = v1 -- Making a duplicate of v1 local v3 = v1:duplicate() -- Changing the x value on -- The reference to v1 v2.x = 5 -- The duplicate of v1 v3.x = 2 -- Printing all 3 vectors to show the difference between -- A referenced vector and a duplicate one print(v1) print(v2) print(v3) number : length_sq () Returns the squared length of the vector (It's much faster than doing length if you need to compare lengths). -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing its squared length print(v1:length_sq()) number : length () Returns the length of the vector . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing its length print(v1:length()) Vector2 : unit () Returns the unit vector of the vector . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Getting the unit vector of v1 local v1_unit = v1:unit() -- Printing it with string method to get more decimal digits -- (If nothing is specified it will have 6 decimal digits the default for string.format(\"%f\")) print(v1_unit:string()) number : dot ( Vector2 : other ) Returns the dot product between the vector and the specified vector . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(3, 2) -- Printing the dot product between the two vectors print(v1:dot(v2)) number : cross ( Vector2 : other ) Returns the cross product between the vector and the specified vector . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(3, 2) -- Printing the cross product between the two vectors print(v1:cross(v2)) Vector2 : rotate ( number : angle ) Returns a Vector2 that is the vector rotated by angle (in radians). -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing the vector rotated by 180\u00b0 print(v1:rotate(math.pi)) string : string ( number : precision ) Returns a string that is equal to (\"(%f; %f)\"):format(v.x, v.y) if precision is specified then the string will show vector's x and y with precision decimal digits . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing the vector with 10 decimal digits print(v1:string(10)) Vector2 Metamethods If you don't know what metamethods are you can go to this link to learn more . Creating a new Vector2 Vector2 implements the __call metamethod, which means that doing math_utils.Vector2.new() is the same as math_utils.Vector2() . It's still better using .new() because only one function is called instead of two , but it can be done both ways. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2(3, 2) -- Printing the two vectors print(v1, v2) tostring(Vector2) Vector2 implements the __tostring metamethod, which means that doing tostring(Vector2) will return Vector2:string(0) . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Converting v1 into string local v1_string = tostring(v1) -- Printing v1's string print(v1_string) Length of Vector2 Note: This only works on ComputerCraft version 1.87+. Vector2 implements the __len metamethod , which means that #Vector2 works. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing the length of the vector print(#v1) Sum of Vector2 Vector2 implements the __add metamethod , which means that Vector2 + Vector2 works. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(3, 2) -- Printing the sum between the two vectors print(v1 + v2) Subtraction of Vector2 Vector2 implements the __sub metamethod , which means that Vector2 - Vector2 works. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(3, 2) -- Printing the subtraction between the two vectors print(v1 - v2) Multiplying a Vector2 by a number Vector2 implements the __mul metamethod , which means that Vector2 * Number works. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing the multiplication between a Vector2 and a number print(v1 * 10) Dividing a Vector2 by a number Vector2 implements the __div metamethod , which means that Vector2 / Number works. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing the division between a Vector2 and a number print(v1 / 2) Checking if two Vector2 are equal NOTE: To check if two vectors have the same length do v1:length_sq() == v2:length_sq() . Vector2 implements the __eq metamethod , which means that Vector2 == Vector2 works. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(10, 2) -- Printing if the two vectors are equal print(v1 == v2) Checking if a Vector2's length is greater than another Vector2's length Vector2 implements the __lt metamethod , which means that Vector2 < Vector2 and Vector2 > Vector2 work. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(3, 2) -- Printing if the length of the first vector is greater than the second one print(v1 > v2) -- Printing if the length of the first vector is lower than the second one print(v1 < v2) Checking if a Vector2's length is greater or equal to another Vector2's length Vector2 implements the __le metamethod , which means that Vector2 <= Vector2 and Vector2 >= Vector2 work. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(3, 2) -- Creating a third vector local v3 = math_utils.Vector2.new(2, 10) -- Printing if the length of the first vector is greater or equal to the second one print(v1 >= v2) -- Printing if the length of the first vector is lower or equal to the third one print(v1 <= v3) Vector3 Vector3 is a 3D vector object . Vector3 Constants It's got eight constants that are pre-defined vectors : key x y z ONE 1 1 1 UP 0 1 0 DOWN 0 -1 0 LEFT -1 0 0 RIGHT 1 0 0 FORWARD 0 0 1 BACK 0 0 -1 ZERO 0 0 0 Vector3 Methods Vector3 : new ( number : x , number : y , number : z ) Returns a new Vector3 that points to ( x ; y ; z ) . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing the vector (Note: tostring(v1) will return v1:string(0), -- if you want more precision you should use v1:string(decimal_digits)) print(v1) Vector3 : duplicate () Returns a new Vector3 that has the same x, y, z as the original Vector3 . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a reference to v1 local v2 = v1 -- Making a duplicate of v1 local v3 = v1:duplicate() -- Changing the x value on -- The reference to v1 v2.x = 5 -- The duplicate of v1 v3.x = 2 -- Printing all 3 vectors to show the difference between -- A referenced vector and a duplicate one print(v1) print(v2) print(v3) number : length_sq () Returns the squared length of the vector (It's much faster than doing length if you need to compare lengths). -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing its squared length print(v1:length_sq()) number : length () Returns the length of the vector . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing its length print(v1:length()) Vector3 : unit () Returns the unit vector of the vector . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Getting the unit vector of v1 local v1_unit = v1:unit() -- Printing it with string method to get more decimal digits -- (If nothing is specified it will have 6 decimal digits the default for string.format(\"%f\")) print(v1_unit:string()) number : dot ( Vector3 : other ) Returns the dot product between the vector and the specified vector . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(3, 2, 10) -- Printing the dot product between the two vectors print(v1:dot(v2)) Vector3 : cross ( Vector3 : other ) Returns the cross product between the vector and the specified vector . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(3, 2, 10) -- Printing the cross product between the two vectors print(v1:cross(v2)) Vector3 : rotate ( Vector3 : axis , number : angle ) Returns a Vector3 that is the vector rotated by angle (in radians) on the specified axis , you can use Vector3 constants as axis. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing the vector rotated by 180\u00b0 on the y axis print(v1.UP, v1:rotate(math.pi)) string : string ( number : precision ) Returns a string that is equal to (\"(%f; %f; %f)\"):format(v.x, v.y, v.z) if precision is specified then the string will show vector's x, y and z with precision decimal digits . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing the vector with 10 decimal digits print(v1:string(10)) Vector3 Metamethods If you don't know what metamethods are you can go to this link to learn more . Creating a new Vector3 Vector3 implements the __call metamethod, which means that doing math_utils.Vector3.new() is the same as math_utils.Vector3() . It's still better using .new() because only one function is called instead of two , but it can be done both ways. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3(3, 2, 10) -- Printing the two vectors print(v1, v2) tostring(Vector3) Vector3 implements the __tostring metamethod , which means that doing tostring(Vector3) will return Vector3:string(0) . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Converting v1 into string local v1_string = tostring(v1) -- Printing v1's string print(v1_string) Length of Vector3 Note: This only works on ComputerCraft version 1.87+. Vector3 implements the __len metamethod , which means that #Vector3 works. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing the length of the vector print(#v1) Sum of Vector3 Vector3 implements the __add metamethod , which means that Vector3 + Vector3 works. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(3, 2, 10) -- Printing the sum between the two vectors print(v1 + v2) Subtraction of Vector3 Vector3 implements the __sub metamethod , which means that Vector3 - Vector3 works. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(3, 2, 10) -- Printing the subtraction between the two vectors print(v1 - v2) Multiplying a Vector3 by a number Vector3 implements the __mul metamethod , which means that Vector3 * Number works. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing the multiplication between a Vector3 and a number print(v1 * 10) Dividing a Vector3 by a number Vector3 implements the __div metamethod , which means that Vector3 / Number works. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing the division between a Vector3 and a number print(v1 / 2) Checking if two Vector3 are equal NOTE: To check if two vectors have the same length do v1:length_sq() == v2:length_sq() . Vector3 implements the __eq metamethod , which means that Vector3 == Vector3 works. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(10, 2, 5) -- Printing if the two vectors are equal print(v1 == v2) Checking if a Vector3's length is greater than another Vector3's length Vector3 implements the __lt metamethod , which means that Vector3 < Vector3 and Vector3 > Vector3 work. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(3, 2, 10) -- Printing if the length of the first vector is greater than the second one print(v1 > v2) -- Printing if the length of the first vector is lower than the second one print(v1 < v2) Checking if a Vector3's length is greater or equal to another Vector3's length Vector3 implements the __le metamethod , which means that Vector3 <= Vector3 and Vector3 >= Vector3 work. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(3, 2, 10) -- Creating a third vector local v3 = math_utils.Vector3.new(2, 10, 5) -- Printing if the length of the first vector is greater or equal to the second one print(v1 >= v2) -- Printing if the length of the first vector is lower or equal to the third one print(v1 <= v3)","title":"Vectors"},{"location":"Modules/Vectors/#vectors","text":"Note that because they're objects all their methods except for new need to be called with \":\" between the object and the method (e.g. v:length() ).","title":"Vectors"},{"location":"Modules/Vectors/#vector2","text":"Vector2 is a 2D vector object .","title":"Vector2"},{"location":"Modules/Vectors/#vector2-constants","text":"It's got six constants that are pre-defined vectors : key x y ONE 1 1 UP 0 -1 DOWN 0 1 LEFT -1 0 RIGHT 1 0 ZERO 0 0","title":"Vector2 Constants"},{"location":"Modules/Vectors/#vector2-methods","text":"Vector2 : new ( number : x , number : y ) Returns a new Vector2 that points to ( x ; y ) . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing the vector (Note: tostring(v1) will return v1:string(0), -- if you want more precision you should use v1:string(decimal_digits)) print(v1) Vector2 : duplicate () Returns a new Vector2 that has the same x, y as the original Vector2 . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a reference to v1 local v2 = v1 -- Making a duplicate of v1 local v3 = v1:duplicate() -- Changing the x value on -- The reference to v1 v2.x = 5 -- The duplicate of v1 v3.x = 2 -- Printing all 3 vectors to show the difference between -- A referenced vector and a duplicate one print(v1) print(v2) print(v3) number : length_sq () Returns the squared length of the vector (It's much faster than doing length if you need to compare lengths). -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing its squared length print(v1:length_sq()) number : length () Returns the length of the vector . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing its length print(v1:length()) Vector2 : unit () Returns the unit vector of the vector . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Getting the unit vector of v1 local v1_unit = v1:unit() -- Printing it with string method to get more decimal digits -- (If nothing is specified it will have 6 decimal digits the default for string.format(\"%f\")) print(v1_unit:string()) number : dot ( Vector2 : other ) Returns the dot product between the vector and the specified vector . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(3, 2) -- Printing the dot product between the two vectors print(v1:dot(v2)) number : cross ( Vector2 : other ) Returns the cross product between the vector and the specified vector . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(3, 2) -- Printing the cross product between the two vectors print(v1:cross(v2)) Vector2 : rotate ( number : angle ) Returns a Vector2 that is the vector rotated by angle (in radians). -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing the vector rotated by 180\u00b0 print(v1:rotate(math.pi)) string : string ( number : precision ) Returns a string that is equal to (\"(%f; %f)\"):format(v.x, v.y) if precision is specified then the string will show vector's x and y with precision decimal digits . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing the vector with 10 decimal digits print(v1:string(10))","title":"Vector2 Methods"},{"location":"Modules/Vectors/#vector2-metamethods","text":"If you don't know what metamethods are you can go to this link to learn more .","title":"Vector2 Metamethods"},{"location":"Modules/Vectors/#creating-a-new-vector2","text":"Vector2 implements the __call metamethod, which means that doing math_utils.Vector2.new() is the same as math_utils.Vector2() . It's still better using .new() because only one function is called instead of two , but it can be done both ways. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2(3, 2) -- Printing the two vectors print(v1, v2)","title":"Creating a new Vector2"},{"location":"Modules/Vectors/#tostringvector2","text":"Vector2 implements the __tostring metamethod, which means that doing tostring(Vector2) will return Vector2:string(0) . -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Converting v1 into string local v1_string = tostring(v1) -- Printing v1's string print(v1_string)","title":"tostring(Vector2)"},{"location":"Modules/Vectors/#length-of-vector2","text":"Note: This only works on ComputerCraft version 1.87+. Vector2 implements the __len metamethod , which means that #Vector2 works. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing the length of the vector print(#v1)","title":"Length of Vector2"},{"location":"Modules/Vectors/#sum-of-vector2","text":"Vector2 implements the __add metamethod , which means that Vector2 + Vector2 works. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(3, 2) -- Printing the sum between the two vectors print(v1 + v2)","title":"Sum of Vector2"},{"location":"Modules/Vectors/#subtraction-of-vector2","text":"Vector2 implements the __sub metamethod , which means that Vector2 - Vector2 works. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(3, 2) -- Printing the subtraction between the two vectors print(v1 - v2)","title":"Subtraction of Vector2"},{"location":"Modules/Vectors/#multiplying-a-vector2-by-a-number","text":"Vector2 implements the __mul metamethod , which means that Vector2 * Number works. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing the multiplication between a Vector2 and a number print(v1 * 10)","title":"Multiplying a Vector2 by a number"},{"location":"Modules/Vectors/#dividing-a-vector2-by-a-number","text":"Vector2 implements the __div metamethod , which means that Vector2 / Number works. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Printing the division between a Vector2 and a number print(v1 / 2)","title":"Dividing a Vector2 by a number"},{"location":"Modules/Vectors/#checking-if-two-vector2-are-equal","text":"NOTE: To check if two vectors have the same length do v1:length_sq() == v2:length_sq() . Vector2 implements the __eq metamethod , which means that Vector2 == Vector2 works. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(10, 2) -- Printing if the two vectors are equal print(v1 == v2)","title":"Checking if two Vector2 are equal"},{"location":"Modules/Vectors/#checking-if-a-vector2s-length-is-greater-than-another-vector2s-length","text":"Vector2 implements the __lt metamethod , which means that Vector2 < Vector2 and Vector2 > Vector2 work. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(3, 2) -- Printing if the length of the first vector is greater than the second one print(v1 > v2) -- Printing if the length of the first vector is lower than the second one print(v1 < v2)","title":"Checking if a Vector2's length is greater than another Vector2's length"},{"location":"Modules/Vectors/#checking-if-a-vector2s-length-is-greater-or-equal-to-another-vector2s-length","text":"Vector2 implements the __le metamethod , which means that Vector2 <= Vector2 and Vector2 >= Vector2 work. -- Creating a new Vector local v1 = math_utils.Vector2.new(10, 2) -- Creating a second Vector local v2 = math_utils.Vector2.new(3, 2) -- Creating a third vector local v3 = math_utils.Vector2.new(2, 10) -- Printing if the length of the first vector is greater or equal to the second one print(v1 >= v2) -- Printing if the length of the first vector is lower or equal to the third one print(v1 <= v3)","title":"Checking if a Vector2's length is greater or equal to another Vector2's length"},{"location":"Modules/Vectors/#vector3","text":"Vector3 is a 3D vector object .","title":"Vector3"},{"location":"Modules/Vectors/#vector3-constants","text":"It's got eight constants that are pre-defined vectors : key x y z ONE 1 1 1 UP 0 1 0 DOWN 0 -1 0 LEFT -1 0 0 RIGHT 1 0 0 FORWARD 0 0 1 BACK 0 0 -1 ZERO 0 0 0","title":"Vector3 Constants"},{"location":"Modules/Vectors/#vector3-methods","text":"Vector3 : new ( number : x , number : y , number : z ) Returns a new Vector3 that points to ( x ; y ; z ) . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing the vector (Note: tostring(v1) will return v1:string(0), -- if you want more precision you should use v1:string(decimal_digits)) print(v1) Vector3 : duplicate () Returns a new Vector3 that has the same x, y, z as the original Vector3 . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a reference to v1 local v2 = v1 -- Making a duplicate of v1 local v3 = v1:duplicate() -- Changing the x value on -- The reference to v1 v2.x = 5 -- The duplicate of v1 v3.x = 2 -- Printing all 3 vectors to show the difference between -- A referenced vector and a duplicate one print(v1) print(v2) print(v3) number : length_sq () Returns the squared length of the vector (It's much faster than doing length if you need to compare lengths). -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing its squared length print(v1:length_sq()) number : length () Returns the length of the vector . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing its length print(v1:length()) Vector3 : unit () Returns the unit vector of the vector . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Getting the unit vector of v1 local v1_unit = v1:unit() -- Printing it with string method to get more decimal digits -- (If nothing is specified it will have 6 decimal digits the default for string.format(\"%f\")) print(v1_unit:string()) number : dot ( Vector3 : other ) Returns the dot product between the vector and the specified vector . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(3, 2, 10) -- Printing the dot product between the two vectors print(v1:dot(v2)) Vector3 : cross ( Vector3 : other ) Returns the cross product between the vector and the specified vector . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(3, 2, 10) -- Printing the cross product between the two vectors print(v1:cross(v2)) Vector3 : rotate ( Vector3 : axis , number : angle ) Returns a Vector3 that is the vector rotated by angle (in radians) on the specified axis , you can use Vector3 constants as axis. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing the vector rotated by 180\u00b0 on the y axis print(v1.UP, v1:rotate(math.pi)) string : string ( number : precision ) Returns a string that is equal to (\"(%f; %f; %f)\"):format(v.x, v.y, v.z) if precision is specified then the string will show vector's x, y and z with precision decimal digits . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing the vector with 10 decimal digits print(v1:string(10))","title":"Vector3 Methods"},{"location":"Modules/Vectors/#vector3-metamethods","text":"If you don't know what metamethods are you can go to this link to learn more .","title":"Vector3 Metamethods"},{"location":"Modules/Vectors/#creating-a-new-vector3","text":"Vector3 implements the __call metamethod, which means that doing math_utils.Vector3.new() is the same as math_utils.Vector3() . It's still better using .new() because only one function is called instead of two , but it can be done both ways. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3(3, 2, 10) -- Printing the two vectors print(v1, v2)","title":"Creating a new Vector3"},{"location":"Modules/Vectors/#tostringvector3","text":"Vector3 implements the __tostring metamethod , which means that doing tostring(Vector3) will return Vector3:string(0) . -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Converting v1 into string local v1_string = tostring(v1) -- Printing v1's string print(v1_string)","title":"tostring(Vector3)"},{"location":"Modules/Vectors/#length-of-vector3","text":"Note: This only works on ComputerCraft version 1.87+. Vector3 implements the __len metamethod , which means that #Vector3 works. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing the length of the vector print(#v1)","title":"Length of Vector3"},{"location":"Modules/Vectors/#sum-of-vector3","text":"Vector3 implements the __add metamethod , which means that Vector3 + Vector3 works. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(3, 2, 10) -- Printing the sum between the two vectors print(v1 + v2)","title":"Sum of Vector3"},{"location":"Modules/Vectors/#subtraction-of-vector3","text":"Vector3 implements the __sub metamethod , which means that Vector3 - Vector3 works. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(3, 2, 10) -- Printing the subtraction between the two vectors print(v1 - v2)","title":"Subtraction of Vector3"},{"location":"Modules/Vectors/#multiplying-a-vector3-by-a-number","text":"Vector3 implements the __mul metamethod , which means that Vector3 * Number works. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing the multiplication between a Vector3 and a number print(v1 * 10)","title":"Multiplying a Vector3 by a number"},{"location":"Modules/Vectors/#dividing-a-vector3-by-a-number","text":"Vector3 implements the __div metamethod , which means that Vector3 / Number works. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Printing the division between a Vector3 and a number print(v1 / 2)","title":"Dividing a Vector3 by a number"},{"location":"Modules/Vectors/#checking-if-two-vector3-are-equal","text":"NOTE: To check if two vectors have the same length do v1:length_sq() == v2:length_sq() . Vector3 implements the __eq metamethod , which means that Vector3 == Vector3 works. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(10, 2, 5) -- Printing if the two vectors are equal print(v1 == v2)","title":"Checking if two Vector3 are equal"},{"location":"Modules/Vectors/#checking-if-a-vector3s-length-is-greater-than-another-vector3s-length","text":"Vector3 implements the __lt metamethod , which means that Vector3 < Vector3 and Vector3 > Vector3 work. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(3, 2, 10) -- Printing if the length of the first vector is greater than the second one print(v1 > v2) -- Printing if the length of the first vector is lower than the second one print(v1 < v2)","title":"Checking if a Vector3's length is greater than another Vector3's length"},{"location":"Modules/Vectors/#checking-if-a-vector3s-length-is-greater-or-equal-to-another-vector3s-length","text":"Vector3 implements the __le metamethod , which means that Vector3 <= Vector3 and Vector3 >= Vector3 work. -- Creating a new Vector local v1 = math_utils.Vector3.new(10, 2, 5) -- Creating a second Vector local v2 = math_utils.Vector3.new(3, 2, 10) -- Creating a third vector local v3 = math_utils.Vector3.new(2, 10, 5) -- Printing if the length of the first vector is greater or equal to the second one print(v1 >= v2) -- Printing if the length of the first vector is lower or equal to the third one print(v1 <= v3)","title":"Checking if a Vector3's length is greater or equal to another Vector3's length"},{"location":"Modules/constants/","text":"Constants Constants can help you future proofing your application . If you use them you're almost certain that if one of them changes value you're safe because you're just using a variable, and your application will automatically use the changed value when the library is updated. Categories Constants can be separated in categories based on what they are used for . Events These constants are useful when you're doing something with a formatted_event , like checking what's the name of the event (e.g. if formatted_event.name == TOUCH then --[[do stuff]] end ) or what mouse button was pressed (e.g. if formatted_event.name == MOUSEUP and formatted_event.button == MOUSE_LEFT then --[[do stuff]] end ). These can also be separated in two main categories . Names All event constants that have to do with the name of an event : TOUCH MOUSEUP MOUSEDRAG MOUSESCROLL CHAR KEY KEYUP PASTE DELETED Inputs All event constants that will help you when you need to check what key or button was pressed : MOUSE_LEFT MOUSE_RIGHT MOUSE_MIDDLE SCROLL_UP SCROLL_DOWN All keys from Keys API except that they're written in UPPERCASE and have the prefix \"KEY_\". Callbacks All constants that will help you to set objects' callbacks through generic_utils.set_callback : ONSTART ONSTOP ONDRAW ONPRESS ONFAILEDPRESS ONTIMEOUT ONCLOCK ONEVENT ONFOCUS ONKEY ONCHAR ONMOUSESCROLL ONCURSORCHANGE ONWRITE Objects These constants are used to set some special properties in objects . This can be separated into two groups . Priority Used to set an object's priority in a Loop (e.g. If something is in high priority it will get moved into the first place of the table that it's in if interacted with): LOW_PRIORITY HIGH_PRIORITY Text Alignment Used to specify text alignment on some objects : ALIGN_LEFT ALIGN_CENTER Computer Type Used to check what type of computer you're on depending on what generic_utils.get_computer_type returns : COMPUTER TURTLE POCKET WSS Response For now this has only the constant that is returned if the computer that hosts a WSS server has disconnected : DISCONNECTED","title":"Constants"},{"location":"Modules/constants/#constants","text":"Constants can help you future proofing your application . If you use them you're almost certain that if one of them changes value you're safe because you're just using a variable, and your application will automatically use the changed value when the library is updated.","title":"Constants"},{"location":"Modules/constants/#categories","text":"Constants can be separated in categories based on what they are used for .","title":"Categories"},{"location":"Modules/constants/#events","text":"These constants are useful when you're doing something with a formatted_event , like checking what's the name of the event (e.g. if formatted_event.name == TOUCH then --[[do stuff]] end ) or what mouse button was pressed (e.g. if formatted_event.name == MOUSEUP and formatted_event.button == MOUSE_LEFT then --[[do stuff]] end ). These can also be separated in two main categories .","title":"Events"},{"location":"Modules/constants/#names","text":"All event constants that have to do with the name of an event : TOUCH MOUSEUP MOUSEDRAG MOUSESCROLL CHAR KEY KEYUP PASTE DELETED","title":"Names"},{"location":"Modules/constants/#inputs","text":"All event constants that will help you when you need to check what key or button was pressed : MOUSE_LEFT MOUSE_RIGHT MOUSE_MIDDLE SCROLL_UP SCROLL_DOWN All keys from Keys API except that they're written in UPPERCASE and have the prefix \"KEY_\".","title":"Inputs"},{"location":"Modules/constants/#callbacks","text":"All constants that will help you to set objects' callbacks through generic_utils.set_callback : ONSTART ONSTOP ONDRAW ONPRESS ONFAILEDPRESS ONTIMEOUT ONCLOCK ONEVENT ONFOCUS ONKEY ONCHAR ONMOUSESCROLL ONCURSORCHANGE ONWRITE","title":"Callbacks"},{"location":"Modules/constants/#objects","text":"These constants are used to set some special properties in objects . This can be separated into two groups .","title":"Objects"},{"location":"Modules/constants/#priority","text":"Used to set an object's priority in a Loop (e.g. If something is in high priority it will get moved into the first place of the table that it's in if interacted with): LOW_PRIORITY HIGH_PRIORITY","title":"Priority"},{"location":"Modules/constants/#text-alignment","text":"Used to specify text alignment on some objects : ALIGN_LEFT ALIGN_CENTER","title":"Text Alignment"},{"location":"Modules/constants/#computer-type","text":"Used to check what type of computer you're on depending on what generic_utils.get_computer_type returns : COMPUTER TURTLE POCKET","title":"Computer Type"},{"location":"Modules/constants/#wss-response","text":"For now this has only the constant that is returned if the computer that hosts a WSS server has disconnected : DISCONNECTED","title":"WSS Response"},{"location":"Modules/generic_utils_module/","text":"generic_utils Contains functions that could be moved into another Module if another function that's similar to one of them is made, it has functions that haven't got their own group yet . set_callback nil : set_callback ( table : gui_element , constant : event , function : callback ) It returns nil . gui_element is the object that you want to add a callback to . event is the callback constant that determines which callback you're setting . callback is the function that is called when the object event was triggered . -- Create a clock that \"ticks\" every second local c = gui_elements.Clock.new(1) -- Add callback for when the clock \"ticks\" generic_utils.set_callback( c, -- object ONCLOCK, -- event function (self) -- callback -- DO STUFF WHEN THE CLOCK TRIGGERS end ) -- Loop that updates the clock while true do sleep(0.1) -- Using sleep to not get \"too long without yielding\" error c:event() end get_computer_type constant , boolean : get_computer_type () Returns a computer type constant and a boolean that's true if the computer is advanced and false if not. -- Get computer type and if it's advanced local computer_type, advanced = generic_utils.get_computer_type() -- Check if computer_type is a COMPUTER if computer_type ~= COMPUTER then printError(\"You must be using a computer to start this script.\") return end -- Check if computer is advanced if not advanced then printError(\"This script only works on advanced computers.\") return end -- DO STUFF expect boolean : expect ( string : context , any : ... ) Returns true if it doesn't error . It checks if even arguments in ... are of type specified by the previous string in ... , if they aren't it errors. context is a string that can be specified by the code that's useful to get more information about the error (Usually it's the function's name) if nil it's \"unknown\" by default . -- Get user input print(\"Insert a number:\") local var1 = read() print(\"Insert a string:\") local var2 = read() -- Convert user input into a number if it is a valid number var1 = tonumber(var1) or var1 var2 = tonumber(var2) or var2 -- Check that the first user input is a number and the second one is a string -- Note: if you want an argument that can be of multiple types you can use a string that -- has multiple types separated by \"/\", \".\" or \",\" (e.g. \"number/string\" or \"number,string\") -- and be aware that types mustn't have spaces in between (They don't get trimmed) else -- it won't work properly local function check_user_input() generic_utils.expect( \"User Input\", \"number\", var1, \"string\", var2 ) end check_user_input()","title":"generic_utils"},{"location":"Modules/generic_utils_module/#generic_utils","text":"Contains functions that could be moved into another Module if another function that's similar to one of them is made, it has functions that haven't got their own group yet .","title":"generic_utils"},{"location":"Modules/generic_utils_module/#set_callback","text":"nil : set_callback ( table : gui_element , constant : event , function : callback ) It returns nil . gui_element is the object that you want to add a callback to . event is the callback constant that determines which callback you're setting . callback is the function that is called when the object event was triggered . -- Create a clock that \"ticks\" every second local c = gui_elements.Clock.new(1) -- Add callback for when the clock \"ticks\" generic_utils.set_callback( c, -- object ONCLOCK, -- event function (self) -- callback -- DO STUFF WHEN THE CLOCK TRIGGERS end ) -- Loop that updates the clock while true do sleep(0.1) -- Using sleep to not get \"too long without yielding\" error c:event() end","title":"set_callback"},{"location":"Modules/generic_utils_module/#get_computer_type","text":"constant , boolean : get_computer_type () Returns a computer type constant and a boolean that's true if the computer is advanced and false if not. -- Get computer type and if it's advanced local computer_type, advanced = generic_utils.get_computer_type() -- Check if computer_type is a COMPUTER if computer_type ~= COMPUTER then printError(\"You must be using a computer to start this script.\") return end -- Check if computer is advanced if not advanced then printError(\"This script only works on advanced computers.\") return end -- DO STUFF","title":"get_computer_type"},{"location":"Modules/generic_utils_module/#expect","text":"boolean : expect ( string : context , any : ... ) Returns true if it doesn't error . It checks if even arguments in ... are of type specified by the previous string in ... , if they aren't it errors. context is a string that can be specified by the code that's useful to get more information about the error (Usually it's the function's name) if nil it's \"unknown\" by default . -- Get user input print(\"Insert a number:\") local var1 = read() print(\"Insert a string:\") local var2 = read() -- Convert user input into a number if it is a valid number var1 = tonumber(var1) or var1 var2 = tonumber(var2) or var2 -- Check that the first user input is a number and the second one is a string -- Note: if you want an argument that can be of multiple types you can use a string that -- has multiple types separated by \"/\", \".\" or \",\" (e.g. \"number/string\" or \"number,string\") -- and be aware that types mustn't have spaces in between (They don't get trimmed) else -- it won't work properly local function check_user_input() generic_utils.expect( \"User Input\", \"number\", var1, \"string\", var2 ) end check_user_input()","title":"expect"},{"location":"Modules/info_module/","text":"info This module/table contains all informations about the library . Keys and Values key type ver string author string website string documentation string copyright string ver : string This string contains the current version of the library . To compare two versions you can use the compare_versions function that's located in string_utils . author : string This string contains the name of the author of the library (He's a cool guy if you ask me \u00b0-\u00b0). website : string This string contains the URL to the library's Github repository . documentation : string This string contains the URL to the library's documentation . copyright : string This string contains the library's copyright notice .","title":"info"},{"location":"Modules/info_module/#info","text":"This module/table contains all informations about the library .","title":"info"},{"location":"Modules/info_module/#keys-and-values","text":"key type ver string author string website string documentation string copyright string","title":"Keys and Values"},{"location":"Modules/info_module/#ver-string","text":"This string contains the current version of the library . To compare two versions you can use the compare_versions function that's located in string_utils .","title":"ver : string"},{"location":"Modules/info_module/#author-string","text":"This string contains the name of the author of the library (He's a cool guy if you ask me \u00b0-\u00b0).","title":"author : string"},{"location":"Modules/info_module/#website-string","text":"This string contains the URL to the library's Github repository .","title":"website : string"},{"location":"Modules/info_module/#documentation-string","text":"This string contains the URL to the library's documentation .","title":"documentation : string"},{"location":"Modules/info_module/#copyright-string","text":"This string contains the library's copyright notice .","title":"copyright : string"},{"location":"Modules/math_utils_module/","text":"math_utils Contains all functions that are helpful when dealing with numbers . Vectors Vectors are going to be explained in this document . map number : map ( number : value , number : value_start , number : value_stop , number : return_start , number : return_stop , boolean : constrained ) Returns a number from a number that is in the range [ value_start ; value_stop ] mapped in the range [ return_start ; return_stop ] and constrained in the return range if constrained is set to true . value is the number that is going to be mapped . value_start is the lowest number that value can be . value_stop is the biggest number that value can be . return_start is the lowest number that the returned number can be . return_start is the biggest number that the returned number can be . constrained if set to true the returned value is going to be constrained to its range of numbers . -- Define the range of value local value_min = 0 local value_max = 10 -- Map value in range without constrain local mapped_value = math_utils.map(2, value_min, value_max, 0, 100, false) -- Map value in range with constrain local mapped_constrained_value = math_utils.map(2, value_min, value_max, 0, 100, true) -- Map value out of range without constrain local mapped_outofrange_value = math_utils.map(11, value_min, value_max, 0, 100, false) -- Map value out of range with constrain local mapped_constrained_outofrange_value = math_utils.map(11, value_min, value_max, 0, 100, true) -- Print mapped values print( string.format( [[ Mapped value: %.2f; Mapped constrained value: %.2f; Mapped out of range value: %.2f; Mapped constrained out of range value: %.2f. ]], mapped_value, mapped_constrained_value, mapped_outofrange_value, mapped_constrained_outofrange_value ) ) constrain number : constrain ( number : value , number : min_value , number : max_value ) It returns a number that is value constrained in the range [ min_value ; max_value ] . value is the number to be constrained . min_value is the lowest number that value can be . max_value is the biggest number that value can be . -- Define the range of value local value_min = 0 local value_max = 10 -- Constrain value in range local constrained_value = math_utils.constrain(2, 0, 10) -- Constrain out of range value in range local constrained_outofrange_value = math_utils.constrain(11, 0, 10) -- Print constrained values print( string.format( [[ Constrained value: %.2f; Constrained out of range value: %.2f. ]], constrained_value, constrained_outofrange_value ) ) round number : round ( number : number ) Returns a number that is number rounded to the closest unit . print( math_utils.round(0.1), math_utils.round(0.6) ) round_numbers numbers : round_numbers ( numbers : ... ) Returns all specified numbers rounded to their closest unit . print( math_utils.round_numbers(0.1, 0.6) ) floor_numbers numbers : floor_numbers ( numbers : ... ) Returns all specified numbers floored . print( math_utils.floor_numbers(0.1, 0.6) ) ceil_numbers numbers : ceil_numbers ( numbers : ... ) Returns all specified numbers ceiled . print( math_utils.ceil_numbers(0.1, 0.6) )","title":"General"},{"location":"Modules/math_utils_module/#math_utils","text":"Contains all functions that are helpful when dealing with numbers .","title":"math_utils"},{"location":"Modules/math_utils_module/#vectors","text":"Vectors are going to be explained in this document .","title":"Vectors"},{"location":"Modules/math_utils_module/#map","text":"number : map ( number : value , number : value_start , number : value_stop , number : return_start , number : return_stop , boolean : constrained ) Returns a number from a number that is in the range [ value_start ; value_stop ] mapped in the range [ return_start ; return_stop ] and constrained in the return range if constrained is set to true . value is the number that is going to be mapped . value_start is the lowest number that value can be . value_stop is the biggest number that value can be . return_start is the lowest number that the returned number can be . return_start is the biggest number that the returned number can be . constrained if set to true the returned value is going to be constrained to its range of numbers . -- Define the range of value local value_min = 0 local value_max = 10 -- Map value in range without constrain local mapped_value = math_utils.map(2, value_min, value_max, 0, 100, false) -- Map value in range with constrain local mapped_constrained_value = math_utils.map(2, value_min, value_max, 0, 100, true) -- Map value out of range without constrain local mapped_outofrange_value = math_utils.map(11, value_min, value_max, 0, 100, false) -- Map value out of range with constrain local mapped_constrained_outofrange_value = math_utils.map(11, value_min, value_max, 0, 100, true) -- Print mapped values print( string.format( [[ Mapped value: %.2f; Mapped constrained value: %.2f; Mapped out of range value: %.2f; Mapped constrained out of range value: %.2f. ]], mapped_value, mapped_constrained_value, mapped_outofrange_value, mapped_constrained_outofrange_value ) )","title":"map"},{"location":"Modules/math_utils_module/#constrain","text":"number : constrain ( number : value , number : min_value , number : max_value ) It returns a number that is value constrained in the range [ min_value ; max_value ] . value is the number to be constrained . min_value is the lowest number that value can be . max_value is the biggest number that value can be . -- Define the range of value local value_min = 0 local value_max = 10 -- Constrain value in range local constrained_value = math_utils.constrain(2, 0, 10) -- Constrain out of range value in range local constrained_outofrange_value = math_utils.constrain(11, 0, 10) -- Print constrained values print( string.format( [[ Constrained value: %.2f; Constrained out of range value: %.2f. ]], constrained_value, constrained_outofrange_value ) )","title":"constrain"},{"location":"Modules/math_utils_module/#round","text":"number : round ( number : number ) Returns a number that is number rounded to the closest unit . print( math_utils.round(0.1), math_utils.round(0.6) )","title":"round"},{"location":"Modules/math_utils_module/#round_numbers","text":"numbers : round_numbers ( numbers : ... ) Returns all specified numbers rounded to their closest unit . print( math_utils.round_numbers(0.1, 0.6) )","title":"round_numbers"},{"location":"Modules/math_utils_module/#floor_numbers","text":"numbers : floor_numbers ( numbers : ... ) Returns all specified numbers floored . print( math_utils.floor_numbers(0.1, 0.6) )","title":"floor_numbers"},{"location":"Modules/math_utils_module/#ceil_numbers","text":"numbers : ceil_numbers ( numbers : ... ) Returns all specified numbers ceiled . print( math_utils.ceil_numbers(0.1, 0.6) )","title":"ceil_numbers"},{"location":"Modules/string_utils_module/","text":"string_utils Contains all functions that are helpful when dealing with strings . This module has a table that's called magic_characters which is used by the escape_magic_characters function to know what characters to escape, you shouldn't change it unless other magic_characters are added and the library isn't updated yet . join string : join ( table : tbl , string : sep ) It returns a string which is all the values of tbl concatenated and separated by sep . tbl is the table which contains all the values you want to concatenate . sep is the string that is going to be put between all concatenated values . -- Create a table that has values in it (join does tostring() on every value before concatenating) local tbl = {\"f\", \"o\", \"o\", \"b\", \"a\", \"r\"} -- Join tbl with two different separators local s1 = string_utils.join(tbl, \"\") local s2 = string_utils.join(tbl, \", \") -- Print joined table print(s1) -- Prints \"foobar\" print(s2) -- Prints \"f, o, o, b, a, r\" split table : split ( string : str , string : sep ) It returns a table which contains all characters in str separated by sep except for sep . str is the string that is going to be split . sep is the string that determines where str is split (this must have more than 0 characters or it will return an empty table). -- Create a string that has some sort of text in it local s = \"f o o b a r\" -- Split s on every empty space local t1 = string_utils.split(s, \" \") -- Join t1 and put a space between every value of it local s1 = string_utils.join(s, \" \") -- Prints the splitted string print(textutils.serialise(t1)) -- Prints the joined table (it should be equal to s) print(s1) compare_versions This can be used to see if the library is a newer version than the one supported by the program . number : compare_versions ( string : v1 , string : v2 ) It returns a number that can be -1, 0 or 1, if it returns -1 then v1 is lower than v2 , if it's 0 they're the same version and if v1 is newer than v2 it returns 1 . -- Store the first compatible version of the library local first_compatible_version = \"1.12.1\" -- Check if compatible (basically info.ver < first_compatible_version) if string_utils.compare_versions(info.ver, first_compatible_version) == -1 then printError(\"This version of YAGUI isn't compatible with this program.\") return end -- WRITE YOUR PROGRAM escape_magic_characters string : escape_magic_characters ( string : str ) Returns a magic character free version of str . str is the string that contains lua's magic characters . -- Create a lua pattern local pattern = \"[^fobar]\" -- Create a string from pattern that hasn't got any magic character local magic_free_pattern = string_utils.escape_magic_characters(pattern) -- Replace pattern with \"\" local str1 = \"If you don't bait me I'll reply\" local s1 = str1:gsub(pattern, \"\") -- Replace magic_free_pattern with \"\" local str2 = \"foo[^fobar]bar\" local s2 = str2:gsub(magic_free_pattern, \"\") -- On str1 the characters that are chosen by the pattern are replaced with \"\" print(s1) -- On str2 pattern is replaced with \"\" print(s2) get_extension string : get_extension ( string : path ) Returns a string that is the extension of the file in path . path is the path of the file that you want to know its extension. -- First file path local f1 = \"./foobar.txt\" -- Get extension of f1 local ext1 = string_utils.get_extension(f1) -- Second file path local f2 = \"./foobar\" -- Get extension of f2 local ext2 = string_utils.get_extension(f2) -- Should print \"txt\" print(ext1) -- Should print \"\" because f2 doesn't have any extension print(ext2) format_number string : format_number ( number : number , number : precision ) Returns a string that is number with precision decimal digits and truncated to the last significant digit . number is the number to be formatted . precision is how many decimal digits the returned string of number should have (if not specified it's 0). -- A number local num = 1405.14008 -- Printing num formatted with 0 decimal digits print( string_utils.format_number(num) ) -- Printing num formatted with 4 decimal digits print( string_utils.format_number(num, 4) ) -- Printing num formatted with 5 decimal digits print( string_utils.format_number(num, 5) ) trim string : trim ( string : str ) Returns str without extra spaces from both sides of the string. str is the string to be trimmed . -- A string local str = \" I don't know how to write , and I want this string to be trimmed ! \" -- Printing the trimmed string concatenated by another one to prove that there is no space between the two print( string_utils.trim(str)..\" There should only be a space here.\" )","title":"string_utils"},{"location":"Modules/string_utils_module/#string_utils","text":"Contains all functions that are helpful when dealing with strings . This module has a table that's called magic_characters which is used by the escape_magic_characters function to know what characters to escape, you shouldn't change it unless other magic_characters are added and the library isn't updated yet .","title":"string_utils"},{"location":"Modules/string_utils_module/#join","text":"string : join ( table : tbl , string : sep ) It returns a string which is all the values of tbl concatenated and separated by sep . tbl is the table which contains all the values you want to concatenate . sep is the string that is going to be put between all concatenated values . -- Create a table that has values in it (join does tostring() on every value before concatenating) local tbl = {\"f\", \"o\", \"o\", \"b\", \"a\", \"r\"} -- Join tbl with two different separators local s1 = string_utils.join(tbl, \"\") local s2 = string_utils.join(tbl, \", \") -- Print joined table print(s1) -- Prints \"foobar\" print(s2) -- Prints \"f, o, o, b, a, r\"","title":"join"},{"location":"Modules/string_utils_module/#split","text":"table : split ( string : str , string : sep ) It returns a table which contains all characters in str separated by sep except for sep . str is the string that is going to be split . sep is the string that determines where str is split (this must have more than 0 characters or it will return an empty table). -- Create a string that has some sort of text in it local s = \"f o o b a r\" -- Split s on every empty space local t1 = string_utils.split(s, \" \") -- Join t1 and put a space between every value of it local s1 = string_utils.join(s, \" \") -- Prints the splitted string print(textutils.serialise(t1)) -- Prints the joined table (it should be equal to s) print(s1)","title":"split"},{"location":"Modules/string_utils_module/#compare_versions","text":"This can be used to see if the library is a newer version than the one supported by the program . number : compare_versions ( string : v1 , string : v2 ) It returns a number that can be -1, 0 or 1, if it returns -1 then v1 is lower than v2 , if it's 0 they're the same version and if v1 is newer than v2 it returns 1 . -- Store the first compatible version of the library local first_compatible_version = \"1.12.1\" -- Check if compatible (basically info.ver < first_compatible_version) if string_utils.compare_versions(info.ver, first_compatible_version) == -1 then printError(\"This version of YAGUI isn't compatible with this program.\") return end -- WRITE YOUR PROGRAM","title":"compare_versions"},{"location":"Modules/string_utils_module/#escape_magic_characters","text":"string : escape_magic_characters ( string : str ) Returns a magic character free version of str . str is the string that contains lua's magic characters . -- Create a lua pattern local pattern = \"[^fobar]\" -- Create a string from pattern that hasn't got any magic character local magic_free_pattern = string_utils.escape_magic_characters(pattern) -- Replace pattern with \"\" local str1 = \"If you don't bait me I'll reply\" local s1 = str1:gsub(pattern, \"\") -- Replace magic_free_pattern with \"\" local str2 = \"foo[^fobar]bar\" local s2 = str2:gsub(magic_free_pattern, \"\") -- On str1 the characters that are chosen by the pattern are replaced with \"\" print(s1) -- On str2 pattern is replaced with \"\" print(s2)","title":"escape_magic_characters"},{"location":"Modules/string_utils_module/#get_extension","text":"string : get_extension ( string : path ) Returns a string that is the extension of the file in path . path is the path of the file that you want to know its extension. -- First file path local f1 = \"./foobar.txt\" -- Get extension of f1 local ext1 = string_utils.get_extension(f1) -- Second file path local f2 = \"./foobar\" -- Get extension of f2 local ext2 = string_utils.get_extension(f2) -- Should print \"txt\" print(ext1) -- Should print \"\" because f2 doesn't have any extension print(ext2)","title":"get_extension"},{"location":"Modules/string_utils_module/#format_number","text":"string : format_number ( number : number , number : precision ) Returns a string that is number with precision decimal digits and truncated to the last significant digit . number is the number to be formatted . precision is how many decimal digits the returned string of number should have (if not specified it's 0). -- A number local num = 1405.14008 -- Printing num formatted with 0 decimal digits print( string_utils.format_number(num) ) -- Printing num formatted with 4 decimal digits print( string_utils.format_number(num, 4) ) -- Printing num formatted with 5 decimal digits print( string_utils.format_number(num, 5) )","title":"format_number"},{"location":"Modules/string_utils_module/#trim","text":"string : trim ( string : str ) Returns str without extra spaces from both sides of the string. str is the string to be trimmed . -- A string local str = \" I don't know how to write , and I want this string to be trimmed ! \" -- Printing the trimmed string concatenated by another one to prove that there is no space between the two print( string_utils.trim(str)..\" There should only be a space here.\" )","title":"trim"}]}